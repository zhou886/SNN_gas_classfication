<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tutorial 2 - The Leaky Integrate-and-Fire Neuron &mdash; snntorch 0.6.2 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/default.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Tutorial 3 - A Feedforward Spiking Neural Network" href="tutorial_3.html" />
    <link rel="prev" title="Tutorial 1 - Spike Encoding" href="tutorial_1.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            snntorch
              <img src="../_static/snntorch_alpha_full.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.6.2
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../readme.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../snntorch.html">snntorch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../snntorch.backprop.html">snntorch.backprop</a></li>
<li class="toctree-l1"><a class="reference internal" href="../snntorch.functional.html">snntorch.functional</a></li>
<li class="toctree-l1"><a class="reference internal" href="../snntorch.spikegen.html">snntorch.spikegen</a></li>
<li class="toctree-l1"><a class="reference internal" href="../snntorch.spikeplot.html">snntorch.spikeplot</a></li>
<li class="toctree-l1"><a class="reference internal" href="../snntorch.spikevision.html">snntorch.spikevision</a></li>
<li class="toctree-l1"><a class="reference internal" href="../snntorch.surrogate.html">snntorch.surrogate</a></li>
<li class="toctree-l1"><a class="reference internal" href="../snntorch.utils.html">snntorch.utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Examples</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Tutorials</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="tutorial_1.html">Tutorial 1 - Spike Encoding</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Tutorial 2 - The Leaky Integrate-and-Fire Neuron</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-spectrum-of-neuron-models">1. The Spectrum of Neuron Models</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-leaky-integrate-and-fire-neuron-model">2. The Leaky Integrate-and-Fire Neuron Model</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#spiking-neurons-intuition">2.1 Spiking Neurons: Intuition</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-passive-membrane">2.2 The Passive Membrane</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#lapicques-lif-neuron-model">3 Lapicque’s LIF Neuron Model</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#lapicque-without-stimulus">3.1 Lapicque: Without Stimulus</a></li>
<li class="toctree-l4"><a class="reference internal" href="#lapicque-step-input">3.2 Lapicque: Step Input</a></li>
<li class="toctree-l4"><a class="reference internal" href="#lapicque-pulse-input">3.3 Lapicque: Pulse Input</a></li>
<li class="toctree-l4"><a class="reference internal" href="#lapicque-firing">3.4 Lapicque: Firing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#lapicque-spike-inputs">3.5 Lapicque: Spike Inputs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#lapicque-reset-mechanisms">3.6 Lapicque: Reset Mechanisms</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#conclusion">Conclusion</a></li>
<li class="toctree-l3"><a class="reference internal" href="#further-reading">Further Reading</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tutorial_3.html">Tutorial 3 - A Feedforward Spiking Neural Network</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial_4.html">Tutorial 4 - 2nd Order Spiking Neuron Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial_5.html">Tutorial 5 - Training Spiking Neural Networks with snntorch</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial_6.html">Tutorial 6 - Surrogate Gradient Descent in a Convolutional SNN</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial_7.html">Tutorial 7 - Neuromorphic Datasets with Tonic + snnTorch</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial_ipu_1.html">Accelerating snnTorch on IPUs</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial_pop.html">Population Coding in Spiking Neural Nets</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial_regression_1.html">Regression with SNNs: Part I</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial_regression_2.html">Regression with SNNs: Part II</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../history.html">History</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">snntorch</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Tutorials</a></li>
      <li class="breadcrumb-item active">Tutorial 2 - The Leaky Integrate-and-Fire Neuron</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/tutorials/tutorial_2.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="tutorial-2-the-leaky-integrate-and-fire-neuron">
<h1>Tutorial 2 - The Leaky Integrate-and-Fire Neuron<a class="headerlink" href="#tutorial-2-the-leaky-integrate-and-fire-neuron" title="Permalink to this headline"></a></h1>
<p>Tutorial written by Jason K. Eshraghian (<a class="reference external" href="https://www.ncg.ucsc.edu">www.ncg.ucsc.edu</a>)</p>
<a class="reference external image-reference" href="https://colab.research.google.com/github/jeshraghian/snntorch/blob/master/examples/tutorial_2_lif_neuron.ipynb"><img alt="Open In Colab" src="https://colab.research.google.com/assets/colab-badge.svg" /></a>
<p>The snnTorch tutorial series is based on the following paper. If you find these resources or code useful in your work, please consider citing the following source:</p>
<blockquote>
<div><p><a class="reference external" href="https://arxiv.org/abs/2109.12894">Jason K. Eshraghian, Max Ward, Emre Neftci, Xinxin Wang, Gregor Lenz, Girish
Dwivedi, Mohammed Bennamoun, Doo Seok Jeong, and Wei D. Lu. “Training
Spiking Neural Networks Using Lessons From Deep Learning”. arXiv preprint arXiv:2109.12894,
September 2021.</a></p>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<dl class="simple">
<dt>This tutorial is a static non-editable version. Interactive, editable versions are available via the following links:</dt><dd><ul class="simple">
<li><p><a class="reference external" href="https://colab.research.google.com/github/jeshraghian/snntorch/blob/master/examples/tutorial_2_lif_neuron.ipynb">Google Colab</a></p></li>
<li><p><a class="reference external" href="https://github.com/jeshraghian/snntorch/tree/master/examples">Local Notebook (download via GitHub)</a></p></li>
</ul>
</dd>
</dl>
</div>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline"></a></h2>
<p>In this tutorial, you will:</p>
<ul class="simple">
<li><p>Learn the fundamentals of the leaky integrate-and-fire (LIF) neuron model</p></li>
<li><p>Use snnTorch to implement a first order LIF neuron</p></li>
</ul>
<p>Install the latest PyPi distribution of snnTorch:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ pip install snntorch
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># imports</span>
<span class="kn">import</span> <span class="nn">snntorch</span> <span class="k">as</span> <span class="nn">snn</span>
<span class="kn">from</span> <span class="nn">snntorch</span> <span class="kn">import</span> <span class="n">spikeplot</span> <span class="k">as</span> <span class="n">splt</span>
<span class="kn">from</span> <span class="nn">snntorch</span> <span class="kn">import</span> <span class="n">spikegen</span>

<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.nn</span> <span class="k">as</span> <span class="nn">nn</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
</section>
<section id="the-spectrum-of-neuron-models">
<h2>1. The Spectrum of Neuron Models<a class="headerlink" href="#the-spectrum-of-neuron-models" title="Permalink to this headline"></a></h2>
<p>A large variety of neuron models are out there, ranging from
biophysically accurate models (i.e., the Hodgkin-Huxley models) to the
extremely simple artificial neuron that pervades all facets of modern
deep learning.</p>
<p><strong>Hodgkin-Huxley Neuron Models</strong><span class="math notranslate nohighlight">\(-\)</span>While biophysical models
can reproduce electrophysiological results with a high degree of
accuracy, their complexity makes them difficult to use at present.</p>
<p><strong>Artificial Neuron Model</strong><span class="math notranslate nohighlight">\(-\)</span>On the other end of the spectrum
is the artificial neuron. The inputs are multiplied by their
corresponding weights and passed through an activation function. This
simplification has enabled deep learning researchers to perform
incredible feats in computer vision, natural language processing, and
many other machine learning-domain tasks.</p>
<p><strong>Leaky Integrate-and-Fire Neuron Models</strong><span class="math notranslate nohighlight">\(-\)</span>Somewhere in the
middle of the divide lies the leaky integrate-and-fire (LIF) neuron
model. It takes the sum of weighted inputs, much like the artificial
neuron. But rather than passing it directly to an activation function,
it will integrate the input over time with a leakage, much like an RC
circuit. If the integrated value exceeds a threshold, then the LIF
neuron will emit a voltage spike. The LIF neuron abstracts away the
shape and profile of the output spike; it is simply treated as a
discrete event. As a result, information is not stored within the spike,
but rather the timing (or frequency) of spikes. Simple spiking neuron
models have produced much insight into the neural code, memory, network
dynamics, and more recently, deep learning. The LIF neuron sits in the
sweet spot between biological plausibility and practicality.</p>
<a class="reference internal image-reference" href="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/2_1_neuronmodels.png?raw=true"><img alt="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/2_1_neuronmodels.png?raw=true" class="align-center" src="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/2_1_neuronmodels.png?raw=true" style="width: 1000px;" /></a>
<p>The different versions of the LIF model each have their own dynamics and
use-cases. snnTorch currently supports the following LIF neurons:</p>
<ul class="simple">
<li><p>Lapicque’s RC model: <code class="docutils literal notranslate"><span class="pre">snntorch.Lapicque</span></code></p></li>
<li><p>1st-order model: <code class="docutils literal notranslate"><span class="pre">snntorch.Leaky</span></code></p></li>
<li><p>Synaptic Conductance-based neuron model: <code class="docutils literal notranslate"><span class="pre">snntorch.Synaptic</span></code></p></li>
<li><p>Recurrent 1st-order model: <code class="docutils literal notranslate"><span class="pre">snntorch.RLeaky</span></code></p></li>
<li><p>Recurrent Synaptic Conductance-based neuron model: <code class="docutils literal notranslate"><span class="pre">snntorch.RSynaptic</span></code></p></li>
<li><p>Alpha neuron model: <code class="docutils literal notranslate"><span class="pre">snntorch.Alpha</span></code></p></li>
</ul>
<p>Several other non-LIF spiking neurons are also available.
This tutorial focuses on the first of these models. This will
be used to build towards the other models in <a class="reference external" href="https://snntorch.readthedocs.io/en/latest/tutorials/index.html">subsequent tutorials</a>.</p>
</section>
<section id="the-leaky-integrate-and-fire-neuron-model">
<h2>2. The Leaky Integrate-and-Fire Neuron Model<a class="headerlink" href="#the-leaky-integrate-and-fire-neuron-model" title="Permalink to this headline"></a></h2>
<section id="spiking-neurons-intuition">
<h3>2.1 Spiking Neurons: Intuition<a class="headerlink" href="#spiking-neurons-intuition" title="Permalink to this headline"></a></h3>
<p>In our brains, a neuron might be connected to 1,000 <span class="math notranslate nohighlight">\(-\)</span> 10,000
other neurons. If one neuron spikes, all downhill neurons might
feel it. But what determines whether a neuron spikes in the first place?
The past century of experiments demonstrate that if a neuron experiences
<em>sufficient</em> stimulus at its input, then it might become excited and fire its own spike.</p>
<p>Where does this stimulus come from? It could be from:</p>
<ul class="simple">
<li><p>the sensory periphery,</p></li>
<li><p>an invasive electrode artificially stimulating the neuron, or in most cases,</p></li>
<li><p>from other pre-synaptic neurons.</p></li>
</ul>
<a class="reference internal image-reference" href="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/2_2_intuition.png?raw=true"><img alt="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/2_2_intuition.png?raw=true" class="align-center" src="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/2_2_intuition.png?raw=true" style="width: 600px;" /></a>
<p>Given that these spikes are very short bursts of electrical activity, it
is quite unlikely for all input spikes to arrive at the neuron body in
precise unison. This indicates the presence of temporal dynamics that
‘sustain’ the input spikes, kind of like a delay.</p>
</section>
<section id="the-passive-membrane">
<h3>2.2 The Passive Membrane<a class="headerlink" href="#the-passive-membrane" title="Permalink to this headline"></a></h3>
<p>Like all cells, a neuron is surrounded by a thin membrane. This membrane
is a lipid bilayer that insulates the conductive saline solution within
the neuron from the extracellular medium. Electrically, the two
conductive solutions separated by an insulator act as a capacitor.</p>
<p>Another function of this membrane is to control what goes in and out of
this cell (e.g., ions such as Na<span class="math notranslate nohighlight">\(^+\)</span>). The membrane is usually
impermeable to ions which blocks them from entering and exiting the
neuron body. But there are specific channels in the membrane that are
triggered to open by injecting current into the neuron. This charge
movement is electrically modelled by a resistor.</p>
<a class="reference internal image-reference" href="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/2_3_passivemembrane.png?raw=true"><img alt="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/2_3_passivemembrane.png?raw=true" class="align-center" src="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/2_3_passivemembrane.png?raw=true" style="width: 450px;" /></a>
<p>The following block will derive the behaviour of a LIF neuron from
scratch. If you’d prefer to skip the math, then feel free to scroll on
by; we’ll take a more hands-on approach to understanding the LIF neuron
dynamics after the derivation.</p>
<hr class="docutils" />
<p><strong>Optional: Derivation of LIF Neuron Model</strong></p>
<p>Now say some arbitrary time-varying current <span class="math notranslate nohighlight">\(I_{\rm in}(t)\)</span> is injected into the neuron,
be it via electrical stimulation or from other neurons. The total current in the circuit is conserved, so:</p>
<div class="math notranslate nohighlight">
\[I_{\rm in}(t) = I_{R} + I_{C}\]</div>
<p>From Ohm’s Law, the membrane potential measured between the inside
and outside of the neuron <span class="math notranslate nohighlight">\(U_{\rm mem}\)</span> is proportional to
the current through the resistor:</p>
<div class="math notranslate nohighlight">
\[I_{R}(t) = \frac{U_{\rm mem}(t)}{R}\]</div>
<p>The capacitance is a proportionality constant between the charge
stored on the capacitor <span class="math notranslate nohighlight">\(Q\)</span> and <span class="math notranslate nohighlight">\(U_{\rm mem}(t)\)</span>:</p>
<div class="math notranslate nohighlight">
\[Q = CU_{\rm mem}(t)\]</div>
<p>The rate of change of charge gives the capacitive current:</p>
<div class="math notranslate nohighlight">
\[\frac{dQ}{dt}=I_C(t) = C\frac{dU_{\rm mem}(t)}{dt}\]</div>
<p>Therefore:</p>
<div class="math notranslate nohighlight">
\[I_{\rm in}(t) = \frac{U_{\rm mem}(t)}{R} + C\frac{dU_{\rm mem}(t)}{dt}\]</div>
<div class="math notranslate nohighlight">
\[\implies RC \frac{dU_{\rm mem}(t)}{dt} = -U_{\rm mem}(t) + RI_{\rm in}(t)\]</div>
<p>The right hand side of the equation is of units
<strong>[Voltage]</strong>. On the left hand side of the equation,
the term <span class="math notranslate nohighlight">\(\frac{dU_{\rm mem}(t)}{dt}\)</span> is of units
<strong>[Voltage/Time]</strong>. To equate it to the left hand side (i.e., voltage),
<span class="math notranslate nohighlight">\(RC\)</span> must be of unit <strong>[Time]</strong>. We refer to <span class="math notranslate nohighlight">\(\tau = RC\)</span> as the time constant of the circuit:</p>
<div class="math notranslate nohighlight">
\[\tau \frac{dU_{\rm mem}(t)}{dt} = -U_{\rm mem}(t) + RI_{\rm in}(t)\]</div>
<p>The passive membrane is therefore described by a linear differential equation.</p>
<p>For a derivative of a function to be of the same form as the original function,
i.e., <span class="math notranslate nohighlight">\(\frac{dU_{\rm mem}(t)}{dt} \propto U_{\rm mem}(t)\)</span>, this implies
the solution is exponential with a time constant <span class="math notranslate nohighlight">\(\tau\)</span>.</p>
<p>Say the neuron starts at some value <span class="math notranslate nohighlight">\(U_{0}\)</span> with no further input,
i.e., <span class="math notranslate nohighlight">\(I_{\rm in}(t)=0.\)</span> The solution of the linear differential equation is:</p>
<div class="math notranslate nohighlight">
\[U_{\rm mem}(t) = U_0e^{-\frac{t}{\tau}}\]</div>
<p>The general solution is shown below.</p>
<a class="reference internal image-reference" href="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/2_4_RCmembrane.png?raw=true"><img alt="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/2_4_RCmembrane.png?raw=true" class="align-center" src="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/2_4_RCmembrane.png?raw=true" style="width: 450px;" /></a>
<hr class="docutils" />
<p><strong>Optional: Forward Euler Method to Solving the LIF Neuron Model</strong></p>
<p>We managed to find the analytical solution to the LIF neuron, but it is
unclear how this might be useful in a neural network. This time,
let’s instead use the forward Euler method to solve the previous linear
ordinary differential equation (ODE). This approach might seem
arduous, but it gives us a discrete, recurrent representation of the LIF
neuron. Once we reach this solution, it can be applied directly to a neural
network. As before, the linear ODE describing the RC circuit is:</p>
<div class="math notranslate nohighlight">
\[\tau \frac{dU(t)}{dt} = -U(t) + RI_{\rm in}(t)\]</div>
<p>The subscript from <span class="math notranslate nohighlight">\(U(t)\)</span> is omitted for simplicity.</p>
<p>First, let’s solve this derivative without taking the limit
<span class="math notranslate nohighlight">\(\Delta t \rightarrow 0\)</span>:</p>
<div class="math notranslate nohighlight">
\[\tau \frac{U(t+\Delta t)-U(t)}{\Delta t} = -U(t) + RI_{\rm in}(t)\]</div>
<p>For a small enough <span class="math notranslate nohighlight">\(\Delta t\)</span>, this gives a good enough
approximation of continuous-time integration. Isolating the membrane at
the following time step gives:</p>
<div class="math notranslate nohighlight">
\[U(t+\Delta t) = U(t) + \frac{\Delta t}{\tau}\big(-U(t) + RI_{\rm in}(t)\big)\]</div>
<p>The following function represents this equation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">leaky_integrate_neuron</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">time_step</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">I</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="mf">5e7</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">):</span>
  <span class="n">tau</span> <span class="o">=</span> <span class="n">R</span><span class="o">*</span><span class="n">C</span>
  <span class="n">U</span> <span class="o">=</span> <span class="n">U</span> <span class="o">+</span> <span class="p">(</span><span class="n">time_step</span><span class="o">/</span><span class="n">tau</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">U</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">R</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">U</span>
</pre></div>
</div>
<p>The default values are set to <span class="math notranslate nohighlight">\(R=50 M\Omega\)</span> and
<span class="math notranslate nohighlight">\(C=100pF\)</span> (i.e., <span class="math notranslate nohighlight">\(\tau=5ms\)</span>). These are quite
realistic with respect to biological neurons.</p>
<p>Now loop through this function, iterating one time step at a time.
The membrane potential is initialized at <span class="math notranslate nohighlight">\(U=0.9 V\)</span>, with the assumption that
there is no injected input current, <span class="math notranslate nohighlight">\(I_{\rm in}=0 A\)</span>.
The simulation is performed with a millisecond precision
<span class="math notranslate nohighlight">\(\Delta t=1\times 10^{-3}\)</span>s.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">num_steps</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">U</span> <span class="o">=</span> <span class="mf">0.9</span>
<span class="n">U_trace</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># keeps a record of U for plotting</span>

<span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_steps</span><span class="p">):</span>
  <span class="n">U_trace</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">U</span><span class="p">)</span>
  <span class="n">U</span> <span class="o">=</span> <span class="n">leaky_integrate_neuron</span><span class="p">(</span><span class="n">U</span><span class="p">)</span>  <span class="c1"># solve next step of U</span>

<span class="n">plot_mem</span><span class="p">(</span><span class="n">U_trace</span><span class="p">,</span> <span class="s2">&quot;Leaky Neuron Model&quot;</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/leaky1.png?raw=true"><img alt="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/leaky1.png?raw=true" class="align-center" src="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/leaky1.png?raw=true" style="width: 300px;" /></a>
<p>This exponential decay seems to match what we expected!</p>
</section>
</section>
<section id="lapicques-lif-neuron-model">
<h2>3 Lapicque’s LIF Neuron Model<a class="headerlink" href="#lapicques-lif-neuron-model" title="Permalink to this headline"></a></h2>
<p>This similarity between nerve membranes and RC circuits was observed by
<a class="reference external" href="https://pubmed.ncbi.nlm.nih.gov/17968583/">Louis Lapicque in
1907</a>. He stimulated
the nerve fiber of a frog with a brief electrical pulse, and found that neuron
membranes could be approximated as a capacitor with a leakage. We pay
homage to his findings by naming the basic LIF neuron model in snnTorch
after him.</p>
<p>Most of the concepts in Lapicque’s model carry forward to other LIF
neuron models. Now it’s time to simulate this neuron using snnTorch.</p>
<section id="lapicque-without-stimulus">
<h3>3.1 Lapicque: Without Stimulus<a class="headerlink" href="#lapicque-without-stimulus" title="Permalink to this headline"></a></h3>
<p>Instantiate Lapicque’s neuron using the following line of code.
R &amp; C are modified to simpler values, while keeping the previous time
constant of <span class="math notranslate nohighlight">\(\tau=5\times10^{-3}\)</span>s.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">time_step</span> <span class="o">=</span> <span class="mf">1e-3</span>
<span class="n">R</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">C</span> <span class="o">=</span> <span class="mf">1e-3</span>

<span class="c1"># leaky integrate and fire neuron, tau=5e-3</span>
<span class="n">lif1</span> <span class="o">=</span> <span class="n">snn</span><span class="o">.</span><span class="n">Lapicque</span><span class="p">(</span><span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="n">C</span><span class="p">,</span> <span class="n">time_step</span><span class="o">=</span><span class="n">time_step</span><span class="p">)</span>
</pre></div>
</div>
<p>The neuron model is now stored in <code class="docutils literal notranslate"><span class="pre">lif1</span></code>. To use this neuron:</p>
<p><strong>Inputs</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">spk_in</span></code>: each element of <span class="math notranslate nohighlight">\(I_{\rm in}\)</span> is sequentially passed as an input (0 for now)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mem</span></code>: the membrane potential, previously <span class="math notranslate nohighlight">\(U[t]\)</span>, is also passed as input. Initialize it arbitrarily as <span class="math notranslate nohighlight">\(U[0] = 0.9~V\)</span>.</p></li>
</ul>
<p><strong>Outputs</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">spk_out</span></code>: output spike <span class="math notranslate nohighlight">\(S_{\rm out}[t+\Delta t]\)</span> at the next time step (‘1’ if there is a spike; ‘0’ if there is no spike)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mem</span></code>: membrane potential <span class="math notranslate nohighlight">\(U_{\rm mem}[t+\Delta t]\)</span> at the next time step</p></li>
</ul>
<p>These all need to be of type <code class="docutils literal notranslate"><span class="pre">torch.Tensor</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Initialize membrane, input, and output</span>
<span class="n">mem</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.9</span>  <span class="c1"># U=0.9 at t=0</span>
<span class="n">cur_in</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_steps</span><span class="p">)</span>  <span class="c1"># I=0 for all t</span>
<span class="n">spk_out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># initialize output spikes</span>
</pre></div>
</div>
<p>These values are only for the initial time step <span class="math notranslate nohighlight">\(t=0\)</span>.
To analyze the evolution of <code class="docutils literal notranslate"><span class="pre">mem</span></code> over time, create a list <code class="docutils literal notranslate"><span class="pre">mem_rec</span></code> to record these values at every time step.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># A list to store a recording of membrane potential</span>
<span class="n">mem_rec</span> <span class="o">=</span> <span class="p">[</span><span class="n">mem</span><span class="p">]</span>
</pre></div>
</div>
<p>Now it’s time to run a simulation! At each time step, <code class="docutils literal notranslate"><span class="pre">mem</span></code> is
updated and stored in <code class="docutils literal notranslate"><span class="pre">mem_rec</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># pass updated value of mem and cur_in[step]=0 at every time step</span>
<span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_steps</span><span class="p">):</span>
  <span class="n">spk_out</span><span class="p">,</span> <span class="n">mem</span> <span class="o">=</span> <span class="n">lif1</span><span class="p">(</span><span class="n">cur_in</span><span class="p">[</span><span class="n">step</span><span class="p">],</span> <span class="n">mem</span><span class="p">)</span>

  <span class="c1"># Store recordings of membrane potential</span>
  <span class="n">mem_rec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mem</span><span class="p">)</span>

<span class="c1"># convert the list of tensors into one tensor</span>
<span class="n">mem_rec</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">mem_rec</span><span class="p">)</span>

<span class="c1"># pre-defined plotting function</span>
<span class="n">plot_mem</span><span class="p">(</span><span class="n">mem_rec</span><span class="p">,</span> <span class="s2">&quot;Lapicque&#39;s Neuron Model Without Stimulus&quot;</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/lapicque.png?raw=true"><img alt="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/lapicque.png?raw=true" class="align-center" src="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/lapicque.png?raw=true" style="width: 300px;" /></a>
<p>The membrane potential decays over time in the absence of any input
stimuli.</p>
</section>
<section id="lapicque-step-input">
<h3>3.2 Lapicque: Step Input<a class="headerlink" href="#lapicque-step-input" title="Permalink to this headline"></a></h3>
<p>Now apply a step current <span class="math notranslate nohighlight">\(I_{\rm in}(t)\)</span> that switches on at
<span class="math notranslate nohighlight">\(t=t_0\)</span>. Given the linear first-order differential equation:</p>
<div class="math notranslate nohighlight">
\[\tau \frac{dU_{\rm mem}}{dt} = -U_{\rm mem} + RI_{\rm in}(t),\]</div>
<p>the general solution is:</p>
<div class="math notranslate nohighlight">
\[U_{\rm mem}=I_{\rm in}(t)R + [U_0 - I_{\rm in}(t)R]e^{-\frac{t}{\tau}}\]</div>
<p>If the membrane potential is initialized to
<span class="math notranslate nohighlight">\(U_{\rm mem}(t=0) = 0 V\)</span>, then:</p>
<div class="math notranslate nohighlight">
\[U_{\rm mem}(t)=I_{\rm in}(t)R [1 - e^{-\frac{t}{\tau}}]\]</div>
<p>Based on this explicit time-dependent form, we expect
<span class="math notranslate nohighlight">\(U_{\rm mem}\)</span> to relax exponentially towards <span class="math notranslate nohighlight">\(I_{\rm in}R\)</span>.
Let’s visualize what this looks like by triggering a current pulse of
<span class="math notranslate nohighlight">\(I_{in}=100mA\)</span> at <span class="math notranslate nohighlight">\(t_0 = 10ms\)</span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Initialize input current pulse</span>
<span class="n">cur_in</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">190</span><span class="p">)</span><span class="o">*</span><span class="mf">0.1</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># input current turns on at t=10</span>

<span class="c1"># Initialize membrane, output and recordings</span>
<span class="n">mem</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># membrane potential of 0 at t=0</span>
<span class="n">spk_out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># neuron needs somewhere to sequentially dump its output spikes</span>
<span class="n">mem_rec</span> <span class="o">=</span> <span class="p">[</span><span class="n">mem</span><span class="p">]</span>
</pre></div>
</div>
<p>This time, the new values of <code class="docutils literal notranslate"><span class="pre">cur_in</span></code> are passed to the neuron:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">num_steps</span> <span class="o">=</span> <span class="mi">200</span>

<span class="c1"># pass updated value of mem and cur_in[step] at every time step</span>
<span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_steps</span><span class="p">):</span>
  <span class="n">spk_out</span><span class="p">,</span> <span class="n">mem</span> <span class="o">=</span> <span class="n">lif1</span><span class="p">(</span><span class="n">cur_in</span><span class="p">[</span><span class="n">step</span><span class="p">],</span> <span class="n">mem</span><span class="p">)</span>
  <span class="n">mem_rec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mem</span><span class="p">)</span>

<span class="c1"># crunch -list- of tensors into one tensor</span>
<span class="n">mem_rec</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">mem_rec</span><span class="p">)</span>

<span class="n">plot_step_current_response</span><span class="p">(</span><span class="n">cur_in</span><span class="p">,</span> <span class="n">mem_rec</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/lapicque_step.png?raw=true"><img alt="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/lapicque_step.png?raw=true" class="align-center" src="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/lapicque_step.png?raw=true" style="width: 450px;" /></a>
<p>As <span class="math notranslate nohighlight">\(t\rightarrow \infty\)</span>, the membrane potential
<span class="math notranslate nohighlight">\(U_{\rm mem}\)</span> exponentially relaxes to <span class="math notranslate nohighlight">\(I_{\rm in}R\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The calculated value of input pulse [A] x resistance [Ω] is: </span><span class="si">{</span><span class="n">cur_in</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span><span class="o">*</span><span class="n">lif1</span><span class="o">.</span><span class="n">R</span><span class="si">}</span><span class="s2"> V&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The simulated value of steady-state membrane potential is: </span><span class="si">{</span><span class="n">mem_rec</span><span class="p">[</span><span class="mi">200</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> V&quot;</span><span class="p">)</span>

<span class="go">The calculated value of input pulse [A] x resistance [Ω] is: 0.5 V</span>
<span class="go">The simulated value of steady-state membrane potential is: 0.4999999403953552 V</span>
</pre></div>
</div>
<p>Close enough!</p>
</section>
<section id="lapicque-pulse-input">
<h3>3.3 Lapicque: Pulse Input<a class="headerlink" href="#lapicque-pulse-input" title="Permalink to this headline"></a></h3>
<p>Now what if the step input was clipped at <span class="math notranslate nohighlight">\(t=30ms\)</span>?</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Initialize current pulse, membrane and outputs</span>
<span class="n">cur_in1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">0.1</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">170</span><span class="p">)),</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># input turns on at t=10, off at t=30</span>
<span class="n">mem</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">spk_out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">mem_rec1</span> <span class="o">=</span> <span class="p">[</span><span class="n">mem</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># neuron simulation</span>
<span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_steps</span><span class="p">):</span>
  <span class="n">spk_out</span><span class="p">,</span> <span class="n">mem</span> <span class="o">=</span> <span class="n">lif1</span><span class="p">(</span><span class="n">cur_in1</span><span class="p">[</span><span class="n">step</span><span class="p">],</span> <span class="n">mem</span><span class="p">)</span>
  <span class="n">mem_rec1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mem</span><span class="p">)</span>
<span class="n">mem_rec1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">mem_rec1</span><span class="p">)</span>

<span class="n">plot_current_pulse_response</span><span class="p">(</span><span class="n">cur_in1</span><span class="p">,</span> <span class="n">mem_rec1</span><span class="p">,</span> <span class="s2">&quot;Lapicque&#39;s Neuron Model With Input Pulse&quot;</span><span class="p">,</span>
                            <span class="n">vline1</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">vline2</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/lapicque_pulse1.png?raw=true"><img alt="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/lapicque_pulse1.png?raw=true" class="align-center" src="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/lapicque_pulse1.png?raw=true" style="width: 450px;" /></a>
<p><span class="math notranslate nohighlight">\(U_{\rm mem}\)</span> rises just as it did for the step input, but now it
decays with a time constant of <span class="math notranslate nohighlight">\(\tau\)</span> as in our first simulation.</p>
<p>Let’s deliver approximately the same amount of charge
<span class="math notranslate nohighlight">\(Q = I \times t\)</span> to the circuit in half the time. This means the
input current amplitude must be increased by a little, and the
time window must be decreased.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Increase amplitude of current pulse; half the time.</span>
<span class="n">cur_in2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">*</span><span class="mf">0.111</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">180</span><span class="p">)),</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># input turns on at t=10, off at t=20</span>
<span class="n">mem</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">spk_out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">mem_rec2</span> <span class="o">=</span> <span class="p">[</span><span class="n">mem</span><span class="p">]</span>

<span class="c1"># neuron simulation</span>
<span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_steps</span><span class="p">):</span>
  <span class="n">spk_out</span><span class="p">,</span> <span class="n">mem</span> <span class="o">=</span> <span class="n">lif1</span><span class="p">(</span><span class="n">cur_in2</span><span class="p">[</span><span class="n">step</span><span class="p">],</span> <span class="n">mem</span><span class="p">)</span>
  <span class="n">mem_rec2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mem</span><span class="p">)</span>
<span class="n">mem_rec2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">mem_rec2</span><span class="p">)</span>

<span class="n">plot_current_pulse_response</span><span class="p">(</span><span class="n">cur_in2</span><span class="p">,</span> <span class="n">mem_rec2</span><span class="p">,</span> <span class="s2">&quot;Lapicque&#39;s Neuron Model With Input Pulse: x1/2 pulse width&quot;</span><span class="p">,</span>
                            <span class="n">vline1</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">vline2</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/lapicque_pulse2.png?raw=true"><img alt="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/lapicque_pulse2.png?raw=true" class="align-center" src="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/lapicque_pulse2.png?raw=true" style="width: 450px;" /></a>
<p>Let’s do that again, but with an even faster input pulse and higher
amplitude:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Increase amplitude of current pulse; quarter the time.</span>
<span class="n">cur_in3</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="mf">0.147</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">185</span><span class="p">)),</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># input turns on at t=10, off at t=15</span>
<span class="n">mem</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">spk_out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">mem_rec3</span> <span class="o">=</span> <span class="p">[</span><span class="n">mem</span><span class="p">]</span>

<span class="c1"># neuron simulation</span>
<span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_steps</span><span class="p">):</span>
  <span class="n">spk_out</span><span class="p">,</span> <span class="n">mem</span> <span class="o">=</span> <span class="n">lif1</span><span class="p">(</span><span class="n">cur_in3</span><span class="p">[</span><span class="n">step</span><span class="p">],</span> <span class="n">mem</span><span class="p">)</span>
  <span class="n">mem_rec3</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mem</span><span class="p">)</span>
<span class="n">mem_rec3</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">mem_rec3</span><span class="p">)</span>

<span class="n">plot_current_pulse_response</span><span class="p">(</span><span class="n">cur_in3</span><span class="p">,</span> <span class="n">mem_rec3</span><span class="p">,</span> <span class="s2">&quot;Lapicque&#39;s Neuron Model With Input Pulse: x1/4 pulse width&quot;</span><span class="p">,</span>
                            <span class="n">vline1</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">vline2</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/lapicque_pulse3.png?raw=true"><img alt="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/lapicque_pulse3.png?raw=true" class="align-center" src="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/lapicque_pulse3.png?raw=true" style="width: 450px;" /></a>
<p>Now compare all three experiments on the same plot:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">compare_plots</span><span class="p">(</span><span class="n">cur_in1</span><span class="p">,</span> <span class="n">cur_in2</span><span class="p">,</span> <span class="n">cur_in3</span><span class="p">,</span> <span class="n">mem_rec1</span><span class="p">,</span> <span class="n">mem_rec2</span><span class="p">,</span> <span class="n">mem_rec3</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span>
              <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="s2">&quot;Lapicque&#39;s Neuron Model With Input Pulse: Varying inputs&quot;</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/compare_pulse.png?raw=true"><img alt="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/compare_pulse.png?raw=true" class="align-center" src="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/compare_pulse.png?raw=true" style="width: 450px;" /></a>
<p>As the input current pulse amplitude increases, the rise time of the
membrane potential speeds up. In the limit of the input current pulse
width becoming infinitesimally small, <span class="math notranslate nohighlight">\(T_W \rightarrow 0s\)</span>, the
membrane potential will jump straight up in virtually zero rise time:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Current spike input</span>
<span class="n">cur_in4</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">189</span><span class="p">)),</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># input only on for 1 time step</span>
<span class="n">mem</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">spk_out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">mem_rec4</span> <span class="o">=</span> <span class="p">[</span><span class="n">mem</span><span class="p">]</span>

<span class="c1"># neuron simulation</span>
<span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_steps</span><span class="p">):</span>
  <span class="n">spk_out</span><span class="p">,</span> <span class="n">mem</span> <span class="o">=</span> <span class="n">lif1</span><span class="p">(</span><span class="n">cur_in4</span><span class="p">[</span><span class="n">step</span><span class="p">],</span> <span class="n">mem</span><span class="p">)</span>
  <span class="n">mem_rec4</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mem</span><span class="p">)</span>
<span class="n">mem_rec4</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">mem_rec4</span><span class="p">)</span>

<span class="n">plot_current_pulse_response</span><span class="p">(</span><span class="n">cur_in4</span><span class="p">,</span> <span class="n">mem_rec4</span><span class="p">,</span> <span class="s2">&quot;Lapicque&#39;s Neuron Model With Input Spike&quot;</span><span class="p">,</span>
                            <span class="n">vline1</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">ylim_max1</span><span class="o">=</span><span class="mf">0.6</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/lapicque_spike.png?raw=true"><img alt="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/lapicque_spike.png?raw=true" class="align-center" src="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/lapicque_spike.png?raw=true" style="width: 450px;" /></a>
<p>The current pulse width is now so short, it effectively looks like a
spike. That is to say, charge is delivered in an infinitely short period
of time, <span class="math notranslate nohighlight">\(I_{\rm in}(t) = Q/t_0\)</span> where <span class="math notranslate nohighlight">\(t_0 \rightarrow 0\)</span>.
More formally:</p>
<div class="math notranslate nohighlight">
\[I_{\rm in}(t) = Q \delta (t-t_0),\]</div>
<p>where <span class="math notranslate nohighlight">\(\delta (t-t_0)\)</span> is the Dirac-Delta function. Physically, it
is impossible to ‘instantaneously’ deposit charge. But integrating
<span class="math notranslate nohighlight">\(I_{\rm in}\)</span> gives a result that makes physical sense, as we can
obtain the charge delivered:</p>
<div class="math notranslate nohighlight">
\[1 = \int^{t_0 + a}_{t_0 - a}\delta(t-t_0)dt\]</div>
<div class="math notranslate nohighlight">
\[f(t_0) = \int^{t_0 + a}_{t_0 - a}f(t)\delta(t-t_0)dt\]</div>
<p>Here,
<span class="math notranslate nohighlight">\(f(t_0) = I_{\rm in}(t_0=10) = 0.5A \implies f(t) = Q = 0.5C\)</span>.</p>
<p>Hopefully you have a good feel of how the membrane potential leaks at
rest, and integrates the input current. That covers the ‘leaky’ and
‘integrate’ part of the neuron. How about the fire?</p>
</section>
<section id="lapicque-firing">
<h3>3.4 Lapicque: Firing<a class="headerlink" href="#lapicque-firing" title="Permalink to this headline"></a></h3>
<p>So far, we have only seen how a neuron will react to spikes at the
input. For a neuron to generate and emit its own spikes at the output,
the passive membrane model must be combined with a threshold.</p>
<p>If the membrane potential exceeds this threshold, then a voltage spike
will be generated, external to the passive membrane model.</p>
<a class="reference internal image-reference" href="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/2_4_spiking.png?raw=true"><img alt="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/2_4_spiking.png?raw=true" class="align-center" src="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/2_4_spiking.png?raw=true" style="width: 400px;" /></a>
<p>Modify the <code class="docutils literal notranslate"><span class="pre">leaky_integrate_neuron</span></code> function from before to add
a spike response.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># R=5.1, C=5e-3 for illustrative purposes</span>
<span class="k">def</span> <span class="nf">leaky_integrate_and_fire</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="n">cur</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">time_step</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="mf">5.1</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="mf">5e-3</span><span class="p">):</span>
  <span class="n">tau_mem</span> <span class="o">=</span> <span class="n">R</span><span class="o">*</span><span class="n">C</span>
  <span class="n">spk</span> <span class="o">=</span> <span class="p">(</span><span class="n">mem</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)</span> <span class="c1"># if membrane exceeds threshold, spk=1, else, 0</span>
  <span class="n">mem</span> <span class="o">=</span> <span class="n">mem</span> <span class="o">+</span> <span class="p">(</span><span class="n">time_step</span><span class="o">/</span><span class="n">tau_mem</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">mem</span> <span class="o">+</span> <span class="n">cur</span><span class="o">*</span><span class="n">R</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">mem</span><span class="p">,</span> <span class="n">spk</span>
</pre></div>
</div>
<p>Set <code class="docutils literal notranslate"><span class="pre">threshold=1</span></code>, and apply a step current to get this neuron
spiking.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Small step current input</span>
<span class="n">cur_in</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">190</span><span class="p">)</span><span class="o">*</span><span class="mf">0.2</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">mem</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">mem_rec</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">spk_rec</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># neuron simulation</span>
<span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_steps</span><span class="p">):</span>
  <span class="n">mem</span><span class="p">,</span> <span class="n">spk</span> <span class="o">=</span> <span class="n">leaky_integrate_and_fire</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="n">cur_in</span><span class="p">[</span><span class="n">step</span><span class="p">])</span>
  <span class="n">mem_rec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mem</span><span class="p">)</span>
  <span class="n">spk_rec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spk</span><span class="p">)</span>

<span class="c1"># convert lists to tensors</span>
<span class="n">mem_rec</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">mem_rec</span><span class="p">)</span>
<span class="n">spk_rec</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">spk_rec</span><span class="p">)</span>

<span class="n">plot_cur_mem_spk</span><span class="p">(</span><span class="n">cur_in</span><span class="p">,</span> <span class="n">mem_rec</span><span class="p">,</span> <span class="n">spk_rec</span><span class="p">,</span> <span class="n">thr_line</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">vline</span><span class="o">=</span><span class="mi">109</span><span class="p">,</span> <span class="n">ylim_max2</span><span class="o">=</span><span class="mf">1.3</span><span class="p">,</span>
                 <span class="n">title</span><span class="o">=</span><span class="s2">&quot;LIF Neuron Model With Uncontrolled Spiking&quot;</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/lif_uncontrolled.png?raw=true"><img alt="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/lif_uncontrolled.png?raw=true" class="align-center" src="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/lif_uncontrolled.png?raw=true" style="width: 450px;" /></a>
<p>Oops - the output spikes have gone out of control! This is
because we forgot to add a reset mechanism. In reality, each time a
neuron fires, the membrane potential hyperpolarizes back to its resting
potential.</p>
<p>Implementing this reset mechanism into our neuron:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># LIF w/Reset mechanism</span>
<span class="k">def</span> <span class="nf">leaky_integrate_and_fire</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="n">cur</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">time_step</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="mf">5.1</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="mf">5e-3</span><span class="p">):</span>
  <span class="n">tau_mem</span> <span class="o">=</span> <span class="n">R</span><span class="o">*</span><span class="n">C</span>
  <span class="n">spk</span> <span class="o">=</span> <span class="p">(</span><span class="n">mem</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)</span>
  <span class="n">mem</span> <span class="o">=</span> <span class="n">mem</span> <span class="o">+</span> <span class="p">(</span><span class="n">time_step</span><span class="o">/</span><span class="n">tau_mem</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">mem</span> <span class="o">+</span> <span class="n">cur</span><span class="o">*</span><span class="n">R</span><span class="p">)</span> <span class="o">-</span> <span class="n">spk</span><span class="o">*</span><span class="n">threshold</span>  <span class="c1"># every time spk=1, subtract the threhsold</span>
  <span class="k">return</span> <span class="n">mem</span><span class="p">,</span> <span class="n">spk</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Small step current input</span>
<span class="n">cur_in</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">190</span><span class="p">)</span><span class="o">*</span><span class="mf">0.2</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">mem</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">mem_rec</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">spk_rec</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># neuron simulation</span>
<span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_steps</span><span class="p">):</span>
  <span class="n">mem</span><span class="p">,</span> <span class="n">spk</span> <span class="o">=</span> <span class="n">leaky_integrate_and_fire</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="n">cur_in</span><span class="p">[</span><span class="n">step</span><span class="p">])</span>
  <span class="n">mem_rec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mem</span><span class="p">)</span>
  <span class="n">spk_rec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spk</span><span class="p">)</span>

<span class="c1"># convert lists to tensors</span>
<span class="n">mem_rec</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">mem_rec</span><span class="p">)</span>
<span class="n">spk_rec</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">spk_rec</span><span class="p">)</span>

<span class="n">plot_cur_mem_spk</span><span class="p">(</span><span class="n">cur_in</span><span class="p">,</span> <span class="n">mem_rec</span><span class="p">,</span> <span class="n">spk_rec</span><span class="p">,</span> <span class="n">thr_line</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">vline</span><span class="o">=</span><span class="mi">109</span><span class="p">,</span> <span class="n">ylim_max2</span><span class="o">=</span><span class="mf">1.3</span><span class="p">,</span>
                 <span class="n">title</span><span class="o">=</span><span class="s2">&quot;LIF Neuron Model With Reset&quot;</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/reset_2.png?raw=true"><img alt="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/reset_2.png?raw=true" class="align-center" src="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/reset_2.png?raw=true" style="width: 450px;" /></a>
<p>Bam. We now have a functional leaky integrate-and-fire neuron model!</p>
<p>Note that if <span class="math notranslate nohighlight">\(I_{\rm in}=0.2 A\)</span> and <span class="math notranslate nohighlight">\(R&lt;5 \Omega\)</span>, then
<span class="math notranslate nohighlight">\(I\times R &lt; 1 V\)</span>. If <code class="docutils literal notranslate"><span class="pre">threshold=1</span></code>, then no spiking would
occur. Feel free to go back up, change the values, and test it out.</p>
<p>As before, all of that code is condensed by calling the built-in Lapicque neuron model from snnTorch:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create the same neuron as before using snnTorch</span>
<span class="n">lif2</span> <span class="o">=</span> <span class="n">snn</span><span class="o">.</span><span class="n">Lapicque</span><span class="p">(</span><span class="n">R</span><span class="o">=</span><span class="mf">5.1</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="mf">5e-3</span><span class="p">,</span> <span class="n">time_step</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Membrane potential time constant: </span><span class="si">{</span><span class="n">lif2</span><span class="o">.</span><span class="n">R</span> <span class="o">*</span> <span class="n">lif2</span><span class="o">.</span><span class="n">C</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
<span class="s2">&quot;Membrane potential time constant: 0.025s&quot;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Initialize inputs and outputs</span>
<span class="n">cur_in</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">190</span><span class="p">)</span><span class="o">*</span><span class="mf">0.2</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">mem</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">spk_out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">mem_rec</span> <span class="o">=</span> <span class="p">[</span><span class="n">mem</span><span class="p">]</span>
<span class="n">spk_rec</span> <span class="o">=</span> <span class="p">[</span><span class="n">spk_out</span><span class="p">]</span>

<span class="c1"># Simulation run across 100 time steps.</span>
<span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_steps</span><span class="p">):</span>
  <span class="n">spk_out</span><span class="p">,</span> <span class="n">mem</span> <span class="o">=</span> <span class="n">lif2</span><span class="p">(</span><span class="n">cur_in</span><span class="p">[</span><span class="n">step</span><span class="p">],</span> <span class="n">mem</span><span class="p">)</span>
  <span class="n">mem_rec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mem</span><span class="p">)</span>
  <span class="n">spk_rec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spk_out</span><span class="p">)</span>

<span class="c1"># convert lists to tensors</span>
<span class="n">mem_rec</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">mem_rec</span><span class="p">)</span>
<span class="n">spk_rec</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">spk_rec</span><span class="p">)</span>

<span class="n">plot_cur_mem_spk</span><span class="p">(</span><span class="n">cur_in</span><span class="p">,</span> <span class="n">mem_rec</span><span class="p">,</span> <span class="n">spk_rec</span><span class="p">,</span> <span class="n">thr_line</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">vline</span><span class="o">=</span><span class="mi">109</span><span class="p">,</span> <span class="n">ylim_max2</span><span class="o">=</span><span class="mf">1.3</span><span class="p">,</span>
                 <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Lapicque Neuron Model With Step Input&quot;</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/lapicque_reset.png?raw=true"><img alt="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/lapicque_reset.png?raw=true" class="align-center" src="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/lapicque_reset.png?raw=true" style="width: 450px;" /></a>
<p>The membrane potential exponentially rises and then hits the threshold,
at which point it resets. We can roughly see this occurs between
<span class="math notranslate nohighlight">\(105ms &lt; t_{\rm spk} &lt; 115ms\)</span>. As a matter of curiousity, let’s
see what the spike recording actually consists of:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">spk_rec</span><span class="p">[</span><span class="mi">105</span><span class="p">:</span><span class="mi">115</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="go">tensor([0., 0., 0., 0., 1., 0., 0., 0., 0., 0.])</span>
</pre></div>
</div>
<p>The absence of a spike is represented by <span class="math notranslate nohighlight">\(S_{\rm out}=0\)</span>, and the
occurrence of a spike is <span class="math notranslate nohighlight">\(S_{\rm out}=1\)</span>. Here, the spike occurs
at <span class="math notranslate nohighlight">\(S_{\rm out}[t=109]=1\)</span>. If you are wondering why each of these entries is stored as a tensor, it
is because in future tutorials we will simulate large scale neural
networks. Each entry will contain the spike responses of many neurons,
and tensors can be loaded into GPU memory to speed up the training
process.</p>
<p>If <span class="math notranslate nohighlight">\(I_{\rm in}\)</span> is increased, then the membrane potential
approaches the threshold <span class="math notranslate nohighlight">\(U_{\rm thr}\)</span> faster:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Initialize inputs and outputs</span>
<span class="n">cur_in</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">190</span><span class="p">)</span><span class="o">*</span><span class="mf">0.3</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># increased current</span>
<span class="n">mem</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">spk_out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">mem_rec</span> <span class="o">=</span> <span class="p">[</span><span class="n">mem</span><span class="p">]</span>
<span class="n">spk_rec</span> <span class="o">=</span> <span class="p">[</span><span class="n">spk_out</span><span class="p">]</span>

<span class="c1"># neuron simulation</span>
<span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_steps</span><span class="p">):</span>
  <span class="n">spk_out</span><span class="p">,</span> <span class="n">mem</span> <span class="o">=</span> <span class="n">lif2</span><span class="p">(</span><span class="n">cur_in</span><span class="p">[</span><span class="n">step</span><span class="p">],</span> <span class="n">mem</span><span class="p">)</span>
  <span class="n">mem_rec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mem</span><span class="p">)</span>
  <span class="n">spk_rec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spk_out</span><span class="p">)</span>

<span class="c1"># convert lists to tensors</span>
<span class="n">mem_rec</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">mem_rec</span><span class="p">)</span>
<span class="n">spk_rec</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">spk_rec</span><span class="p">)</span>


<span class="n">plot_cur_mem_spk</span><span class="p">(</span><span class="n">cur_in</span><span class="p">,</span> <span class="n">mem_rec</span><span class="p">,</span> <span class="n">spk_rec</span><span class="p">,</span> <span class="n">thr_line</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ylim_max2</span><span class="o">=</span><span class="mf">1.3</span><span class="p">,</span>
                 <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Lapicque Neuron Model With Periodic Firing&quot;</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/periodic.png?raw=true"><img alt="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/periodic.png?raw=true" class="align-center" src="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/periodic.png?raw=true" style="width: 450px;" /></a>
<p>A similar increase in firing frequency can also be induced by decreasing
the threshold. This requires initializing a new neuron model, but the
rest of the code block is the exact same as above:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># neuron with halved threshold</span>
<span class="n">lif3</span> <span class="o">=</span> <span class="n">snn</span><span class="o">.</span><span class="n">Lapicque</span><span class="p">(</span><span class="n">R</span><span class="o">=</span><span class="mf">5.1</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="mf">5e-3</span><span class="p">,</span> <span class="n">time_step</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Initialize inputs and outputs</span>
<span class="n">cur_in</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">190</span><span class="p">)</span><span class="o">*</span><span class="mf">0.3</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">mem</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">spk_out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">mem_rec</span> <span class="o">=</span> <span class="p">[</span><span class="n">mem</span><span class="p">]</span>
<span class="n">spk_rec</span> <span class="o">=</span> <span class="p">[</span><span class="n">spk_out</span><span class="p">]</span>

<span class="c1"># Neuron simulation</span>
<span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_steps</span><span class="p">):</span>
  <span class="n">spk_out</span><span class="p">,</span> <span class="n">mem</span> <span class="o">=</span> <span class="n">lif3</span><span class="p">(</span><span class="n">cur_in</span><span class="p">[</span><span class="n">step</span><span class="p">],</span> <span class="n">mem</span><span class="p">)</span>
  <span class="n">mem_rec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mem</span><span class="p">)</span>
  <span class="n">spk_rec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spk_out</span><span class="p">)</span>

<span class="c1"># convert lists to tensors</span>
<span class="n">mem_rec</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">mem_rec</span><span class="p">)</span>
<span class="n">spk_rec</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">spk_rec</span><span class="p">)</span>

<span class="n">plot_cur_mem_spk</span><span class="p">(</span><span class="n">cur_in</span><span class="p">,</span> <span class="n">mem_rec</span><span class="p">,</span> <span class="n">spk_rec</span><span class="p">,</span> <span class="n">thr_line</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">ylim_max2</span><span class="o">=</span><span class="mf">1.3</span><span class="p">,</span>
                 <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Lapicque Neuron Model With Lower Threshold&quot;</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/threshold.png?raw=true"><img alt="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/threshold.png?raw=true" class="align-center" src="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/threshold.png?raw=true" style="width: 450px;" /></a>
<p>That’s what happens for a constant current injection. But in both deep
neural networks and in the biological brain, most neurons will be
connected to other neurons. They are more likely to receive spikes,
rather than injections of constant current.</p>
</section>
<section id="lapicque-spike-inputs">
<h3>3.5 Lapicque: Spike Inputs<a class="headerlink" href="#lapicque-spike-inputs" title="Permalink to this headline"></a></h3>
<p>Let’s harness some of the skills we learnt in <a class="reference external" href="https://colab.research.google.com/github/jeshraghian/snntorch/blob/master/examples/tutorial_1_spikegen.ipynb">Tutorial
1</a>,
and use the <code class="docutils literal notranslate"><span class="pre">snntorch.spikegen</span></code> module to create some randomly
generated input spikes.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a 1-D random spike train. Each element has a probability of 40% of firing.</span>
<span class="n">spk_in</span> <span class="o">=</span> <span class="n">spikegen</span><span class="o">.</span><span class="n">rate_conv</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">num_steps</span><span class="p">))</span> <span class="o">*</span> <span class="mf">0.40</span><span class="p">)</span>
</pre></div>
</div>
<p>Run the following code block to see how many spikes have been generated.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;There are </span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">spk_in</span><span class="p">))</span><span class="si">}</span><span class="s2"> total spikes out of </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spk_in</span><span class="p">)</span><span class="si">}</span><span class="s2"> time steps.&quot;</span><span class="p">)</span>
<span class="go">There are 85 total spikes out of 200 time steps.</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">facecolor</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>

<span class="n">splt</span><span class="o">.</span><span class="n">raster</span><span class="p">(</span><span class="n">spk_in</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">num_steps</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">ax</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;|&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Input Spikes&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Time step&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">([])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/spikes.png?raw=true"><img alt="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/spikes.png?raw=true" class="align-center" src="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/spikes.png?raw=true" style="width: 400px;" /></a>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Initialize inputs and outputs</span>
<span class="n">mem</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span>
<span class="n">spk_out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">mem_rec</span> <span class="o">=</span> <span class="p">[</span><span class="n">mem</span><span class="p">]</span>
<span class="n">spk_rec</span> <span class="o">=</span> <span class="p">[</span><span class="n">spk_out</span><span class="p">]</span>

<span class="c1"># Neuron simulation</span>
<span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_steps</span><span class="p">):</span>
  <span class="n">spk_out</span><span class="p">,</span> <span class="n">mem</span> <span class="o">=</span> <span class="n">lif3</span><span class="p">(</span><span class="n">spk_in</span><span class="p">[</span><span class="n">step</span><span class="p">],</span> <span class="n">mem</span><span class="p">)</span>
  <span class="n">spk_rec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spk_out</span><span class="p">)</span>
  <span class="n">mem_rec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mem</span><span class="p">)</span>

<span class="c1"># convert lists to tensors</span>
<span class="n">mem_rec</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">mem_rec</span><span class="p">)</span>
<span class="n">spk_rec</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">spk_rec</span><span class="p">)</span>

<span class="n">plot_spk_mem_spk</span><span class="p">(</span><span class="n">spk_in</span><span class="p">,</span> <span class="n">mem_rec</span><span class="p">,</span> <span class="n">spk_out</span><span class="p">,</span> <span class="s2">&quot;Lapicque&#39;s Neuron Model With Input Spikes&quot;</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/spk_mem_spk.png?raw=true"><img alt="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/spk_mem_spk.png?raw=true" class="align-center" src="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/spk_mem_spk.png?raw=true" style="width: 450px;" /></a>
</section>
<section id="lapicque-reset-mechanisms">
<h3>3.6 Lapicque: Reset Mechanisms<a class="headerlink" href="#lapicque-reset-mechanisms" title="Permalink to this headline"></a></h3>
<p>We already implemented a reset mechanism from scratch, but let’s dive a
little deeper. This sharp drop of membrane potential promotes a
reduction of spike generation, which supplements part of the theory on
how brains are so power efficient. Biologically, this drop of membrane
potential is known as ‘hyperpolarization’. Following that, it is
momentarily more difficult to elicit another spike from the neuron.
Here, we use a reset mechanism to model hyperpolarization.</p>
<p>There are two ways to implement the reset mechanism:</p>
<ol class="arabic simple">
<li><p><em>reset by subtraction</em> (default) <span class="math notranslate nohighlight">\(-\)</span> subtract the threshold
from the membrane potential each time a spike is generated;</p></li>
<li><p><em>reset to zero</em> <span class="math notranslate nohighlight">\(-\)</span> force the membrane potential to zero each
time a spike is generated.</p></li>
<li><p><em>no reset</em> <span class="math notranslate nohighlight">\(-\)</span> do nothing, and let the firing go potentially uncontrolled.</p></li>
</ol>
<a class="reference internal image-reference" href="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/2_5_reset.png?raw=true"><img alt="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/2_5_reset.png?raw=true" class="align-center" src="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/2_5_reset.png?raw=true" style="width: 400px;" /></a>
<p>Instantiate another neuron model to demonstrate how to alternate
between reset mechanisms. By default, snnTorch neuron models use <code class="docutils literal notranslate"><span class="pre">reset_mechanism</span> <span class="pre">=</span> <span class="pre">&quot;subtract&quot;</span></code>.
This can be explicitly overridden by passing the argument
<code class="docutils literal notranslate"><span class="pre">reset_mechanism</span> <span class="pre">=</span>&#160; <span class="pre">&quot;zero&quot;</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Neuron with reset_mechanism set to &quot;zero&quot;</span>
<span class="n">lif4</span> <span class="o">=</span> <span class="n">snn</span><span class="o">.</span><span class="n">Lapicque</span><span class="p">(</span><span class="n">R</span><span class="o">=</span><span class="mf">5.1</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="mf">5e-3</span><span class="p">,</span> <span class="n">time_step</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">reset_mechanism</span><span class="o">=</span><span class="s2">&quot;zero&quot;</span><span class="p">)</span>

<span class="c1"># Initialize inputs and outputs</span>
<span class="n">spk_in</span> <span class="o">=</span> <span class="n">spikegen</span><span class="o">.</span><span class="n">rate_conv</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">num_steps</span><span class="p">))</span> <span class="o">*</span> <span class="mf">0.40</span><span class="p">)</span>
<span class="n">mem</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span>
<span class="n">spk_out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">mem_rec0</span> <span class="o">=</span> <span class="p">[</span><span class="n">mem</span><span class="p">]</span>
<span class="n">spk_rec0</span> <span class="o">=</span> <span class="p">[</span><span class="n">spk_out</span><span class="p">]</span>

<span class="c1"># Neuron simulation</span>
<span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_steps</span><span class="p">):</span>
  <span class="n">spk_out</span><span class="p">,</span> <span class="n">mem</span> <span class="o">=</span> <span class="n">lif4</span><span class="p">(</span><span class="n">spk_in</span><span class="p">[</span><span class="n">step</span><span class="p">],</span> <span class="n">mem</span><span class="p">)</span>
  <span class="n">spk_rec0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spk_out</span><span class="p">)</span>
  <span class="n">mem_rec0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mem</span><span class="p">)</span>

<span class="c1"># convert lists to tensors</span>
<span class="n">mem_rec0</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">mem_rec0</span><span class="p">)</span>
<span class="n">spk_rec0</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">spk_rec0</span><span class="p">)</span>

<span class="n">plot_reset_comparison</span><span class="p">(</span><span class="n">spk_in</span><span class="p">,</span> <span class="n">mem_rec</span><span class="p">,</span> <span class="n">spk_rec</span><span class="p">,</span> <span class="n">mem_rec0</span><span class="p">,</span> <span class="n">spk_rec0</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/comparison.png?raw=true"><img alt="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/comparison.png?raw=true" class="align-center" src="https://github.com/jeshraghian/snntorch/blob/master/docs/_static/img/examples/tutorial2/_static/comparison.png?raw=true" style="width: 550px;" /></a>
<p>Pay close attention to the evolution of the membrane potential,
especially in the moments after it reaches the threshold. You may notice
that for “Reset to Zero”, the membrane potential is forced back to zero
after each spike.</p>
<p>So which one is better? Applying <code class="docutils literal notranslate"><span class="pre">&quot;subtract&quot;</span></code> (the default value in
<code class="docutils literal notranslate"><span class="pre">reset_mechanism</span></code>) is less lossy, because it does not ignore how much
the membrane exceeds the threshold by.</p>
<p>On the other hand, applying a hard reset with <code class="docutils literal notranslate"><span class="pre">&quot;zero&quot;</span></code> promotes
sparsity and potentially less power consumption when running on
dedicated neuromorphic hardware. Both options are available for you to
experiment with.</p>
<p>That covers the basics of a LIF neuron model!</p>
</section>
</section>
<section id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this headline"></a></h2>
<p>In practice, we probably wouldn’t use this neuron model to train a
neural network. The Lapicque LIF model has added a lot of
hyperparameters to tune: <span class="math notranslate nohighlight">\(R\)</span>, <span class="math notranslate nohighlight">\(C\)</span>, <span class="math notranslate nohighlight">\(\Delta t\)</span>,
<span class="math notranslate nohighlight">\(U_{\rm thr}\)</span>, and the choice of reset mechanism. It’s all a
little bit daunting. So the <a class="reference external" href="https://snntorch.readthedocs.io/en/latest/tutorials/index.html">next tutorial</a> will eliminate most of these
hyperparameters, and introduce a neuron model that is better suited for
large-scale deep learning.</p>
<p>If you like this project, please consider starring ⭐ the repo on GitHub as it is the easiest and best way to support it.</p>
<p>For reference, the documentation <a class="reference external" href="https://snntorch.readthedocs.io/en/latest/snntorch.html">can be found
here</a>.</p>
</section>
<section id="further-reading">
<h2>Further Reading<a class="headerlink" href="#further-reading" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/jeshraghian/snntorch">Check out the snnTorch GitHub project here.</a></p></li>
<li><p><a class="reference external" href="https://snntorch.readthedocs.io/en/latest/snntorch.html">snnTorch
documentation</a>
of the Lapicque, Leaky, Synaptic, and Alpha models</p></li>
<li><p><a class="reference external" href="https://neuronaldynamics.epfl.ch/index.html">Neuronal Dynamics: From single neurons to networks and models of
cognition</a> by Wulfram
Gerstner, Werner M. Kistler, Richard Naud and Liam Paninski.</p></li>
<li><p><a class="reference external" href="https://mitpress.mit.edu/books/theoretical-neuroscience">Theoretical Neuroscience: Computational and Mathematical Modeling of
Neural
Systems</a>
by Laurence F. Abbott and Peter Dayan</p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="tutorial_1.html" class="btn btn-neutral float-left" title="Tutorial 1 - Spike Encoding" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="tutorial_3.html" class="btn btn-neutral float-right" title="Tutorial 3 - A Feedforward Spiking Neural Network" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Jason K. Eshraghian.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>