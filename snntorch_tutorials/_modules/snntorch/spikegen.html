<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>snntorch.spikegen &mdash; snntorch 0.6.2 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/default.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            snntorch
              <img src="../../_static/snntorch_alpha_full.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.6.2
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../snntorch.html">snntorch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../snntorch.backprop.html">snntorch.backprop</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../snntorch.functional.html">snntorch.functional</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../snntorch.spikegen.html">snntorch.spikegen</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../snntorch.spikeplot.html">snntorch.spikeplot</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../snntorch.spikevision.html">snntorch.spikevision</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../snntorch.surrogate.html">snntorch.surrogate</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../snntorch.utils.html">snntorch.utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../history.html">History</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">snntorch</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">snntorch.spikegen</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for snntorch.spikegen</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">torch</span>

<span class="n">dtype</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">float</span>


<div class="viewcode-block" id="rate"><a class="viewcode-back" href="../../snntorch.spikegen.html#snntorch.spikegen.rate">[docs]</a><span class="k">def</span> <span class="nf">rate</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">num_steps</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">gain</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">first_spike_time</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">time_var_input</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Spike rate encoding of input data. Convert tensor into Poisson spike</span>
<span class="sd">    trains using the features as the mean of a</span>
<span class="sd">    binomial distribution. If `num_steps` is specified, then the data will be</span>
<span class="sd">    first repeated in the first dimension</span>
<span class="sd">    before rate encoding.</span>

<span class="sd">    If data is time-varying, tensor dimensions use time first.</span>

<span class="sd">    Example::</span>

<span class="sd">        # 100% chance of spike generation</span>
<span class="sd">        a = torch.Tensor([1, 1, 1, 1])</span>
<span class="sd">        spikegen.rate(a, num_steps=1)</span>
<span class="sd">        &gt;&gt;&gt; tensor([1., 1., 1., 1.])</span>

<span class="sd">        # 0% chance of spike generation</span>
<span class="sd">        b = torch.Tensor([0, 0, 0, 0])</span>
<span class="sd">        spikegen.rate(b, num_steps=1)</span>
<span class="sd">        &gt;&gt;&gt; tensor([0., 0., 0., 0.])</span>

<span class="sd">        # 50% chance of spike generation per time step</span>
<span class="sd">        c = torch.Tensor([0.5, 0.5, 0.5, 0.5])</span>
<span class="sd">        spikegen.rate(c, num_steps=1)</span>
<span class="sd">        &gt;&gt;&gt; tensor([0., 1., 0., 1.])</span>

<span class="sd">        # Increasing num_steps will increase the length of the first</span>
<span class="sd">        dimension (time-first)</span>
<span class="sd">        print(c.size())</span>
<span class="sd">        &gt;&gt;&gt; torch.Size([1, 4])</span>

<span class="sd">        d = spikegen.rate(torch.Tensor([0.5, 0.5, 0.5, 0.5]), num_steps = 2)</span>
<span class="sd">        print(d.size())</span>
<span class="sd">        &gt;&gt;&gt; torch.Size([2, 4])</span>


<span class="sd">    :param data: Data tensor for a single batch of shape [batch x input_size]</span>
<span class="sd">    :type data: torch.Tensor</span>

<span class="sd">    :param num_steps: Number of time steps. Only specify if input data</span>
<span class="sd">        does not already have time dimension, defaults to ``False``</span>
<span class="sd">    :type num_steps: int, optional</span>

<span class="sd">    :param gain: Scale input features by the gain, defaults to ``1``</span>
<span class="sd">    :type gain: float, optional</span>

<span class="sd">    :param offset: Shift input features by the offset, defaults to ``0``</span>
<span class="sd">    :type offset: torch.optim, optional</span>

<span class="sd">    :param first_spike_time: Time to first spike, defaults to ``0``.</span>
<span class="sd">    :type first_spike_time: int, optional</span>

<span class="sd">    :param time_var_input: Set to ``True`` if input tensor is time-varying.</span>
<span class="sd">        Otherwise, `first_spike_time!=0` will modify the wrong dimension.</span>
<span class="sd">        Defaults to ``False``</span>
<span class="sd">    :type time_var_input: bool, optional</span>

<span class="sd">    :return: rate encoding spike train of input features of shape</span>
<span class="sd">        [num_steps x batch x input_size]</span>
<span class="sd">    :rtype: torch.Tensor</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">first_spike_time</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">num_steps</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
            <span class="s2">&quot;``first_spike_time`` and ``num_steps`` cannot be negative.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">first_spike_time</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">num_steps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">num_steps</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;first_spike_time (</span><span class="si">{</span><span class="n">first_spike_time</span><span class="si">}</span><span class="s2">) must be equal to &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;or less than num_steps-1 (</span><span class="si">{</span><span class="n">num_steps</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2">).&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">time_var_input</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;If the input data is time-varying, set &quot;</span>
                <span class="s2">&quot;``time_var_input=True``.</span><span class="se">\n</span><span class="s2"> If the input data is not &quot;</span>
                <span class="s2">&quot;time-varying, ensure ``num_steps &gt; 0``.&quot;</span>
            <span class="p">)</span>

    <span class="k">if</span> <span class="n">first_spike_time</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">time_var_input</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">num_steps</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
            <span class="s2">&quot;``num_steps`` must be specified if both the input is not &quot;</span>
            <span class="s2">&quot;time-varying and ``first_spike_time`` is greater than 0.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">time_var_input</span> <span class="ow">and</span> <span class="n">num_steps</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
            <span class="s2">&quot;``num_steps`` should not be specified if input is &quot;</span>
            <span class="s2">&quot;time-varying, i.e., ``time_var_input=True``.</span><span class="se">\n</span><span class="s2"> &quot;</span>
            <span class="s2">&quot;The first dimension of the input data + ``first_spike_time`` &quot;</span>
            <span class="s2">&quot;will determine ``num_steps``.&quot;</span>
        <span class="p">)</span>

    <span class="n">device</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">device</span>

    <span class="c1"># intended for time-varying input data</span>
    <span class="k">if</span> <span class="n">time_var_input</span><span class="p">:</span>
        <span class="n">spike_data</span> <span class="o">=</span> <span class="n">rate_conv</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="c1"># zeros are added directly to the start of 0th (time) dimension</span>
        <span class="k">if</span> <span class="n">first_spike_time</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">spike_data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                        <span class="nb">tuple</span><span class="p">([</span><span class="n">first_spike_time</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">spike_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">())),</span>
                        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
                        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                    <span class="p">),</span>
                    <span class="n">spike_data</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>

    <span class="c1"># intended for time-static input data</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="c1"># Generate a tuple: (num_steps, 1..., 1) where the number of 1&#39;s</span>
        <span class="c1"># = number of dimensions in the original data.</span>
        <span class="c1"># Multiply by gain and add offset.</span>
        <span class="n">time_data</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">data</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
                <span class="nb">tuple</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">num_steps</span><span class="p">]</span>
                    <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">size</span><span class="p">()),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="o">*</span> <span class="n">gain</span>
            <span class="o">+</span> <span class="n">offset</span>
        <span class="p">)</span>

        <span class="n">spike_data</span> <span class="o">=</span> <span class="n">rate_conv</span><span class="p">(</span><span class="n">time_data</span><span class="p">)</span>

        <span class="c1"># zeros are multiplied by the start of the 0th (time) dimension</span>
        <span class="k">if</span> <span class="n">first_spike_time</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">spike_data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">first_spike_time</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">return</span> <span class="n">spike_data</span></div>


<div class="viewcode-block" id="latency"><a class="viewcode-back" href="../../snntorch.spikegen.html#snntorch.spikegen.latency">[docs]</a><span class="k">def</span> <span class="nf">latency</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">num_steps</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">threshold</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
    <span class="n">tau</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">first_spike_time</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">on_target</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">off_target</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">clip</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">interpolate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">bypass</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Latency encoding of input or target label data. Use input features</span>
<span class="sd">    to determine time-to-first spike. Expected inputs should be</span>
<span class="sd">    between 0 and 1.</span>

<span class="sd">    Assume a LIF neuron model that charges up with time constant tau.</span>
<span class="sd">    Tensor dimensions use time first.</span>

<span class="sd">    Example::</span>

<span class="sd">        a = torch.Tensor([0.02, 0.5, 1])</span>
<span class="sd">        spikegen.latency(a, num_steps=5, normalize=True, linear=True)</span>
<span class="sd">        &gt;&gt;&gt; tensor([[0., 0., 1.],</span>
<span class="sd">                    [0., 0., 0.],</span>
<span class="sd">                    [0., 1., 0.],</span>
<span class="sd">                    [0., 0., 0.],</span>
<span class="sd">                    [1., 0., 0.]])</span>

<span class="sd">    :param data: Data tensor for a single batch of shape [batch x input_size]</span>
<span class="sd">    :type data: torch.Tensor</span>

<span class="sd">    :param num_steps: Number of time steps. Explicitly needed if</span>
<span class="sd">        ``normalize=True``, defaults to ``False`` (then changed to ``1``</span>
<span class="sd">        if ``normalize=False``)</span>
<span class="sd">    :type num_steps: int, optional</span>

<span class="sd">    :param threshold: Input features below the threhold will fire at the</span>
<span class="sd">        final time step unless ``clip=True`` in which case they will not</span>
<span class="sd">        fire at all, defaults to ``0.01``</span>
<span class="sd">    :type threshold: float, optional</span>

<span class="sd">    :param tau:  RC Time constant for LIF model used to calculate</span>
<span class="sd">        firing time, defaults to ``1``</span>
<span class="sd">    :type tau: float, optional</span>

<span class="sd">    :param first_spike_time: Time to first spike, defaults to ``0``.</span>
<span class="sd">    :type first_spike_time: int, optional</span>

<span class="sd">    :param on_target: Target at spike times, defaults to ``1``</span>
<span class="sd">    :type on_target: float, optional</span>

<span class="sd">    :param off_target: Target during refractory period, defaults to ``0``</span>
<span class="sd">    :type off_target: float, optional</span>

<span class="sd">    :param clip: Option to remove spikes from features that fall</span>
<span class="sd">        below the threshold, defaults to ``False``</span>
<span class="sd">    :type clip: Bool, optional</span>

<span class="sd">    :param normalize: Option to normalize the latency code such</span>
<span class="sd">        that the final spike(s) occur within num_steps, defaults to ``False``</span>
<span class="sd">    :type normalize: Bool, optional</span>

<span class="sd">    :param linear: Apply a linear latency code rather than the</span>
<span class="sd">        default logarithmic code, defaults to ``False``</span>
<span class="sd">    :type linear: Bool, optional</span>

<span class="sd">    :param interpolate: Applies linear interpolation such that</span>
<span class="sd">        there is a gradually increasing target up to each spike, defaults to</span>
<span class="sd">        ``False``</span>
<span class="sd">    :type interpolate: Bool, optional</span>

<span class="sd">    :param bypass: Used to block error messages that occur from either: i)</span>
<span class="sd">        spike times exceeding the bounds of ``num_steps``, or ii) if</span>
<span class="sd">        ``num_steps`` is not specified, setting ``bypass=True``</span>
<span class="sd">        allows the largest spike time to set ``num_steps``. Defaults to</span>
<span class="sd">        ``False``</span>
<span class="sd">    :type bypass: bool, optional</span>

<span class="sd">    :param epsilon: A tiny positive value to avoid rounding errors</span>
<span class="sd">        when using torch.arange, defaults to ``1e-7``</span>
<span class="sd">    :type epsilon: float, optional</span>

<span class="sd">    :return: latency encoding spike train of features or labels</span>
<span class="sd">    :rtype: torch.Tensor</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Elements of ``data`` must be between [0, 1], but input &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;is [</span><span class="si">{</span><span class="n">torch</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2">]&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">threshold</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">threshold</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;``threshold`` [</span><span class="si">{</span><span class="n">threshold</span><span class="si">}</span><span class="s2">] must be between [0, 1]&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">num_steps</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">bypass</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
            <span class="s2">&quot;``num_steps`` must be specified. Alternatively, setting &quot;</span>
            <span class="s2">&quot;``bypass=True`` will automatically set ``num_steps`` &quot;</span>
            <span class="s2">&quot;to the last spike time. This may lead to uneven tensor &quot;</span>
            <span class="s2">&quot;sizes when used in a loop.&quot;</span>
        <span class="p">)</span>

    <span class="n">device</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">device</span>

    <span class="n">spike_time</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">latency_code</span><span class="p">(</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">num_steps</span><span class="o">=</span><span class="n">num_steps</span><span class="p">,</span>
        <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span>
        <span class="n">tau</span><span class="o">=</span><span class="n">tau</span><span class="p">,</span>
        <span class="n">first_spike_time</span><span class="o">=</span><span class="n">first_spike_time</span><span class="p">,</span>
        <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span>
        <span class="n">linear</span><span class="o">=</span><span class="n">linear</span><span class="p">,</span>
        <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># automatically set num_steps using max element in spike_time</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">num_steps</span> <span class="ow">and</span> <span class="n">bypass</span><span class="p">:</span>
        <span class="n">num_steps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">spike_time</span><span class="p">))</span><span class="o">.</span><span class="n">long</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">num_steps</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;``num_steps`` [</span><span class="si">{</span><span class="n">num_steps</span><span class="si">}</span><span class="s2">] must be positive. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;This can be specifiedInput data should be normalized &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;to larger values or ``threshold`` should be set to a &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;smaller value.&quot;</span>
            <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">spike_time</span><span class="p">))</span><span class="o">.</span><span class="n">long</span><span class="p">()</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">num_steps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="ow">and</span> <span class="ow">not</span> <span class="n">bypass</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;The maximum value in ``spike_time`` &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">torch</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">spike_time</span><span class="p">))</span><span class="o">.</span><span class="n">long</span><span class="p">()</span><span class="si">}</span><span class="s2">] is out of &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;bounds for ``num_steps`` [</span><span class="si">{</span><span class="n">num_steps</span><span class="si">}</span><span class="s2">-1].</span><span class="se">\n</span><span class="s2"> To bypass &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;this error, set ``bypass=True``.</span><span class="se">\n</span><span class="s2"> Alternatively, constrain &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;``spike_time`` within the range of ``num_steps`` &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;by either decreasing ``tau`` or ``setting normalize=True``.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">interpolate</span><span class="p">:</span>

        <span class="n">spike_data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">num_steps</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">spike_time</span><span class="o">.</span><span class="n">size</span><span class="p">()))),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># use rm_idx to remove spikes beyond the range of num_steps</span>
        <span class="n">rm_idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">spike_time</span><span class="p">)</span><span class="o">.</span><span class="n">long</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">num_steps</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">spike_data</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">spike_data</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">clamp_max</span><span class="p">(</span><span class="n">spike_time</span><span class="p">,</span> <span class="n">num_steps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="o">.</span><span class="n">long</span><span class="p">()</span>
                <span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                <span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="o">*</span> <span class="o">~</span><span class="n">rm_idx</span>
        <span class="p">)</span>

        <span class="c1"># Use idx to remove spikes below the threshold</span>
        <span class="k">if</span> <span class="n">clip</span><span class="p">:</span>
            <span class="n">spike_data</span> <span class="o">=</span> <span class="n">spike_data</span> <span class="o">*</span> <span class="o">~</span><span class="n">idx</span>  <span class="c1"># idx is broadcast in T direction</span>

        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">spike_data</span> <span class="o">*</span> <span class="n">on_target</span><span class="p">,</span> <span class="n">off_target</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">interpolate</span><span class="p">:</span>

        <span class="k">return</span> <span class="n">latency_interpolate</span><span class="p">(</span>
            <span class="n">spike_time</span><span class="p">,</span> <span class="n">num_steps</span><span class="p">,</span> <span class="n">on_target</span><span class="o">=</span><span class="n">on_target</span><span class="p">,</span> <span class="n">off_target</span><span class="o">=</span><span class="n">off_target</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="delta"><a class="viewcode-back" href="../../snntorch.spikegen.html#snntorch.spikegen.delta">[docs]</a><span class="k">def</span> <span class="nf">delta</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">threshold</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
    <span class="n">padding</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">off_spike</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate spike only when the difference between two subsequent</span>
<span class="sd">    time steps meets a threshold.</span>
<span class="sd">    Optionally include off_spikes for negative changes.</span>

<span class="sd">    Example::</span>

<span class="sd">        a = torch.Tensor([1, 2, 2.9, 3, 3.9])</span>
<span class="sd">        spikegen.delta(a, threshold=1)</span>
<span class="sd">        &gt;&gt;&gt; tensor([1., 1., 0., 1., 0.])</span>

<span class="sd">        spikegen.delta(a, threshold=1, padding=True)</span>
<span class="sd">        &gt;&gt;&gt; tensor([0., 1., 0., 1., 0.])</span>

<span class="sd">        b = torch.Tensor([1, 2, 0, 2, 2.9])</span>
<span class="sd">        spikegen.delta(b, threshold=1, off_spike=True)</span>
<span class="sd">        &gt;&gt;&gt; tensor([ 1.,  1., -1.,  1.,  0.])</span>

<span class="sd">        spikegen.delta(b, threshold=1, padding=True, off_spike=True)</span>
<span class="sd">        &gt;&gt;&gt; tensor([ 0.,  1., -1.,  1.,  0.])</span>

<span class="sd">    :param data: Data tensor for a single batch of shape [num_steps x batch</span>
<span class="sd">        x input_size]</span>
<span class="sd">    :type data: torch.Tensor</span>

<span class="sd">    :param threshold: Input features with a change greater than the thresold</span>
<span class="sd">        across one timestep will generate a spike, defaults to ``0.1``</span>
<span class="sd">    :type thr: float, optional</span>

<span class="sd">    :param padding: Used to change how the first time step of spikes are</span>
<span class="sd">        measured. If ``True``, the first time step will be repeated with itself</span>
<span class="sd">        resulting in ``0``&#39;s for the output spikes.</span>
<span class="sd">        If ``False``, the first time step will be padded with ``0``&#39;s, defaults</span>
<span class="sd">        to ``False``</span>
<span class="sd">    :type padding: bool, optional</span>

<span class="sd">    :param off_spike: If ``True``, negative spikes for changes less than</span>
<span class="sd">        ``-threshold``, defaults to ``False``</span>
<span class="sd">    :type off_spike: bool, optional</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">padding</span><span class="p">:</span>
        <span class="n">data_offset</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">data</span><span class="p">))[</span>
            <span class="p">:</span><span class="o">-</span><span class="mi">1</span>
        <span class="p">]</span>  <span class="c1"># duplicate first time step, remove final step</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data_offset</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span>
            <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">data</span><span class="p">)</span>
        <span class="p">)[</span>
            <span class="p">:</span><span class="o">-</span><span class="mi">1</span>
        <span class="p">]</span>  <span class="c1"># add 0&#39;s to first step, remove final step</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">off_spike</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">data</span> <span class="o">-</span> <span class="n">data_offset</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">on_spk</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">data</span> <span class="o">-</span> <span class="n">data_offset</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">)</span>
        <span class="n">off_spk</span> <span class="o">=</span> <span class="o">-</span><span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">data</span> <span class="o">-</span> <span class="n">data_offset</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">threshold</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">on_spk</span> <span class="o">+</span> <span class="n">off_spk</span></div>


<div class="viewcode-block" id="rate_conv"><a class="viewcode-back" href="../../snntorch.spikegen.html#snntorch.spikegen.rate_conv">[docs]</a><span class="k">def</span> <span class="nf">rate_conv</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert tensor into Poisson spike trains using the features as</span>
<span class="sd">    the mean of a binomial distribution.</span>
<span class="sd">    Values outside the range of [0, 1] are clipped so they can be</span>
<span class="sd">    treated as probabilities.</span>

<span class="sd">        Example::</span>

<span class="sd">            # 100% chance of spike generation</span>
<span class="sd">            a = torch.Tensor([1, 1, 1, 1])</span>
<span class="sd">            spikegen.rate_conv(a)</span>
<span class="sd">            &gt;&gt;&gt; tensor([1., 1., 1., 1.])</span>

<span class="sd">            # 0% chance of spike generation</span>
<span class="sd">            b = torch.Tensor([0, 0, 0, 0])</span>
<span class="sd">            spikegen.rate_conv(b)</span>
<span class="sd">            &gt;&gt;&gt; tensor([0., 0., 0., 0.])</span>

<span class="sd">            # 50% chance of spike generation per time step</span>
<span class="sd">            c = torch.Tensor([0.5, 0.5, 0.5, 0.5])</span>
<span class="sd">            spikegen.rate_conv(c)</span>
<span class="sd">            &gt;&gt;&gt; tensor([0., 1., 0., 1.])</span>

<span class="sd">    :param data: Data tensor for a single batch of shape [batch x input_size]</span>
<span class="sd">    :type data: torch.Tensor</span>

<span class="sd">    :return: rate encoding spike train of input features of shape</span>
<span class="sd">        [num_steps x batch x input_size]</span>
<span class="sd">    :rtype: torch.Tensor</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Clip all features between 0 and 1 so they can be used as</span>
    <span class="c1"># probabilities.</span>
    <span class="n">clipped_data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># pass time_data matrix into bernoulli function.</span>
    <span class="n">spike_data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">bernoulli</span><span class="p">(</span><span class="n">clipped_data</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">spike_data</span></div>


<div class="viewcode-block" id="latency_code"><a class="viewcode-back" href="../../snntorch.spikegen.html#snntorch.spikegen.latency_code">[docs]</a><span class="k">def</span> <span class="nf">latency_code</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">num_steps</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">threshold</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
    <span class="n">tau</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">first_spike_time</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Latency encoding of input data. Convert input features or</span>
<span class="sd">    target labels to spike times. Assumes a LIF neuron model</span>
<span class="sd">    that charges up with time constant tau by default.</span>

<span class="sd">    Example::</span>

<span class="sd">        a = torch.Tensor([0.02, 0.5, 1])</span>
<span class="sd">        spikegen.latency_code(a, num_steps=5, normalize=True, linear=True)</span>
<span class="sd">        &gt;&gt;&gt; (tensor([3.9200, 2.0000, 0.0000]), tensor([False, False, False]))</span>

<span class="sd">    :param data: Data tensor for a single batch of shape [batch x input_size]</span>
<span class="sd">    :type data: torch.Tensor</span>

<span class="sd">    :param num_steps: Number of time steps. Explicitly needed if</span>
<span class="sd">        ``normalize=True``, defaults to ``False`` (then changed to ``1``</span>
<span class="sd">        if ``normalize=False``)</span>
<span class="sd">    :type num_steps: int, optional</span>

<span class="sd">    :param threshold: Input features below the threhold will fire at</span>
<span class="sd">        the final time step unless ``clip=True`` in which case they will</span>
<span class="sd">        not fire at all, defaults to ``0.01``</span>
<span class="sd">    :type threshold: float, optional</span>

<span class="sd">    :param tau:  RC Time constant for LIF model used to calculate</span>
<span class="sd">        firing time, defaults to ``1``</span>
<span class="sd">    :type tau: float, optional</span>

<span class="sd">    :param first_spike_time: Time to first spike, defaults to ``0``.</span>
<span class="sd">    :type first_spike_time: int, optional</span>

<span class="sd">    :param normalize: Option to normalize the latency code such</span>
<span class="sd">        that the final spike(s) occur within num_steps, defaults to ``False``</span>
<span class="sd">    :type normalize: Bool, optional</span>

<span class="sd">    :param linear: Apply a linear latency code rather than the</span>
<span class="sd">        default logarithmic code, defaults to ``False``</span>
<span class="sd">    :type linear: Bool, optional</span>

<span class="sd">    :param epsilon: A tiny positive value to avoid rounding errors</span>
<span class="sd">        when using torch.arange, defaults to ``1e-7``</span>
<span class="sd">    :type epsilon: float, optional</span>

<span class="sd">    :return: latency encoding spike times of features</span>
<span class="sd">    :rtype: torch.Tensor</span>

<span class="sd">    :return: Tensor of Boolean values which correspond to the</span>
<span class="sd">        latency encoding elements that fall below the threshold.</span>
<span class="sd">        Used in ``latency_conv`` to clip saturated spikes.</span>
<span class="sd">    :rtype: torch.Tensor</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">idx</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&lt;</span> <span class="n">threshold</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">linear</span><span class="p">:</span>
        <span class="n">spike_time</span> <span class="o">=</span> <span class="n">latency_code_log</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">num_steps</span><span class="o">=</span><span class="n">num_steps</span><span class="p">,</span>
            <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span>
            <span class="n">tau</span><span class="o">=</span><span class="n">tau</span><span class="p">,</span>
            <span class="n">first_spike_time</span><span class="o">=</span><span class="n">first_spike_time</span><span class="p">,</span>
            <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span>
            <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">elif</span> <span class="n">linear</span><span class="p">:</span>
        <span class="n">spike_time</span> <span class="o">=</span> <span class="n">latency_code_linear</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">num_steps</span><span class="o">=</span><span class="n">num_steps</span><span class="p">,</span>
            <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span>
            <span class="n">tau</span><span class="o">=</span><span class="n">tau</span><span class="p">,</span>
            <span class="n">first_spike_time</span><span class="o">=</span><span class="n">first_spike_time</span><span class="p">,</span>
            <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">spike_time</span><span class="p">,</span> <span class="n">idx</span></div>


<div class="viewcode-block" id="latency_code_linear"><a class="viewcode-back" href="../../snntorch.spikegen.html#snntorch.spikegen.latency_code_linear">[docs]</a><span class="k">def</span> <span class="nf">latency_code_linear</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">num_steps</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">threshold</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
    <span class="n">tau</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">first_spike_time</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Linear latency encoding of input data. Convert input features</span>
<span class="sd">    or target labels to spike times.</span>

<span class="sd">    Example::</span>

<span class="sd">        a = torch.Tensor([0.02, 0.5, 1])</span>
<span class="sd">        spikegen.latency_code(a, num_steps=5, normalize=True, linear=True)</span>
<span class="sd">        &gt;&gt;&gt; (tensor([3.9200, 2.0000, 0.0000]), tensor([False, False, False]))</span>

<span class="sd">    :param data: Data tensor for a single batch of shape [batch x input_size]</span>
<span class="sd">    :type data: torch.Tensor</span>

<span class="sd">    :param num_steps: Number of time steps. Explicitly needed if</span>
<span class="sd">        ``normalize=True``, defaults to ``False``</span>
<span class="sd">        (then changed to ``1`` if ``normalize=False``)</span>
<span class="sd">    :type num_steps: int, optional</span>

<span class="sd">    :param threshold: Input features below the threhold will</span>
<span class="sd">        fire at the final time step, defaults to ``0.01``</span>
<span class="sd">    :type threshold: float, optional</span>

<span class="sd">    :param tau:  Linear time constant used to calculate firing time,</span>
<span class="sd">        defaults to ``1``</span>
<span class="sd">    :type tau: float, optional</span>

<span class="sd">    :param first_spike_time: Time to first spike, defaults to ``0``.</span>
<span class="sd">    :type first_spike_time: int, optional</span>

<span class="sd">    :param normalize: Option to normalize the latency code such that</span>
<span class="sd">        the final spike(s) occur within num_steps, defaults to ``False``</span>
<span class="sd">    :type normalize: Bool, optional</span>

<span class="sd">    :return: linear latency encoding spike times of features</span>
<span class="sd">    :rtype: torch.Tensor</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_latency_errors</span><span class="p">(</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">num_steps</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">first_spike_time</span><span class="p">,</span> <span class="n">normalize</span>
    <span class="p">)</span>  <span class="c1"># error checks</span>

    <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">num_steps</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">first_spike_time</span>

    <span class="n">spike_time</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">clamp_max</span><span class="p">((</span><span class="o">-</span><span class="n">tau</span> <span class="o">*</span> <span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)),</span> <span class="o">-</span><span class="n">tau</span> <span class="o">*</span> <span class="p">(</span><span class="n">threshold</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="p">)</span> <span class="o">+</span> <span class="n">first_spike_time</span>

    <span class="c1"># the following code is intended for negative input data.</span>
    <span class="c1"># it is more broadly caught in latency code by ensuring 0 &lt; data &lt; 1.</span>
    <span class="c1"># Consider disabling ~(0&lt;data&lt;1) input.</span>
    <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">spike_time</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">normalize</span><span class="p">:</span>
        <span class="n">spike_time</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">spike_time</span> <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">spike_time</span><span class="p">))</span>
            <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">spike_time</span><span class="p">)</span> <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">spike_time</span><span class="p">)))</span>
            <span class="o">*</span> <span class="p">(</span><span class="n">num_steps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">spike_time</span></div>


<div class="viewcode-block" id="latency_code_log"><a class="viewcode-back" href="../../snntorch.spikegen.html#snntorch.spikegen.latency_code_log">[docs]</a><span class="k">def</span> <span class="nf">latency_code_log</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">num_steps</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">threshold</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
    <span class="n">tau</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">first_spike_time</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">,</span>
<span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Logarithmic latency encoding of input data. Convert input features</span>
<span class="sd">    or target labels to spike times.</span>

<span class="sd">    Example::</span>

<span class="sd">        a = torch.Tensor([0.02, 0.5, 1])</span>
<span class="sd">        spikegen.latency_code(a, num_steps=5, normalize=True)</span>
<span class="sd">        &gt;&gt;&gt; (tensor([4.0000, 0.1166, 0.0580]), tensor([False, False, False]))</span>

<span class="sd">    :param data: Data tensor for a single batch of shape [batch x input_size]</span>
<span class="sd">    :type data: torch.Tensor</span>

<span class="sd">    :param num_steps: Number of time steps. Explicitly needed if</span>
<span class="sd">        ``normalize=True``, defaults to ``False`` (then changed to ``1`` if</span>
<span class="sd">        ``normalize=False``)</span>
<span class="sd">    :type num_steps: int, optional</span>

<span class="sd">    :param threshold: Input features below the threhold will fire at the</span>
<span class="sd">        final time step, defaults to ``0.01``</span>
<span class="sd">    :type threshold: float, optional</span>

<span class="sd">    :param tau: Logarithmic time constant used to calculate firing time,</span>
<span class="sd">        defaults to ``1``</span>
<span class="sd">    :type tau: float, optional</span>

<span class="sd">    :param first_spike_time: Time to first spike, defaults to ``0``.</span>
<span class="sd">    :type first_spike_time: int, optional</span>

<span class="sd">    :param normalize: Option to normalize the latency code such that</span>
<span class="sd">        the final spike(s) occur within num_steps, defaults to ``False``</span>
<span class="sd">    :type normalize: Bool, optional</span>

<span class="sd">    :param epsilon: A tiny positive value to avoid rounding errors when</span>
<span class="sd">        using torch.arange, defaults to ``1e-7``</span>
<span class="sd">    :type epsilon: float, optional</span>

<span class="sd">    :return: logarithmic latency encoding spike times of features</span>
<span class="sd">    :rtype: torch.Tensor</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_latency_errors</span><span class="p">(</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">num_steps</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">first_spike_time</span><span class="p">,</span> <span class="n">normalize</span>
    <span class="p">)</span>  <span class="c1"># error checks</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">threshold</span> <span class="o">+</span> <span class="n">epsilon</span>
    <span class="p">)</span>  <span class="c1"># saturates all values below threshold.</span>

    <span class="n">spike_time</span> <span class="o">=</span> <span class="n">tau</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">data</span> <span class="o">/</span> <span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">threshold</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">first_spike_time</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">spike_time</span> <span class="o">+=</span> <span class="n">first_spike_time</span>

    <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
        <span class="n">spike_time</span> <span class="o">=</span> <span class="p">(</span><span class="n">spike_time</span> <span class="o">-</span> <span class="n">first_spike_time</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
            <span class="n">num_steps</span> <span class="o">-</span> <span class="n">first_spike_time</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="p">)</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">spike_time</span> <span class="o">-</span> <span class="n">first_spike_time</span><span class="p">)</span> <span class="o">+</span> <span class="n">first_spike_time</span>

    <span class="k">return</span> <span class="n">spike_time</span></div>


<span class="k">def</span> <span class="nf">_latency_errors</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">num_steps</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">first_spike_time</span><span class="p">,</span> <span class="n">normalize</span>
<span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Catch errors for spike time encoding latency functions</span>
<span class="sd">    ``latency_code_linear`` and ``latency_code_log``&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span>
        <span class="n">threshold</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">threshold</span> <span class="o">&gt;=</span> <span class="mi">1</span>
    <span class="p">):</span>  <span class="c1"># double check if this can just be threshold &lt; 0 instead.</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Threshold must be between 0 and 1.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">tau</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># double check if this can just be threshold &lt; 0 instead.</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;``tau`` must be greater than 0.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">first_spike_time</span> <span class="ow">and</span> <span class="n">num_steps</span> <span class="ow">and</span> <span class="n">first_spike_time</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">num_steps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;first_spike_time (</span><span class="si">{</span><span class="n">first_spike_time</span><span class="si">}</span><span class="s2">) must be equal to &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;or less than num_steps-1 (</span><span class="si">{</span><span class="n">num_steps</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2">).&quot;</span>
        <span class="p">)</span>

    <span class="c1"># this condition is more broadly caught in latency code by ensuring 0</span>
    <span class="c1"># &lt; data &lt; 1</span>
    <span class="k">if</span> <span class="n">first_spike_time</span> <span class="ow">and</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">torch</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
            <span class="s2">&quot;`first_spike_time` can only be applied to data between &quot;</span>
            <span class="s2">&quot;`0` and `1`.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">first_spike_time</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
            <span class="s2">&quot;``first_spike_time`` [</span><span class="si">{first_spike_time}</span><span class="s2">] cannot be negative.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">num_steps</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;``num_steps`` [</span><span class="si">{num_steps}</span><span class="s2">] cannot be negative.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">normalize</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">num_steps</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
            <span class="s2">&quot;`num_steps` should not be empty if normalize is set to True.&quot;</span>
        <span class="p">)</span>


<div class="viewcode-block" id="targets_convert"><a class="viewcode-back" href="../../snntorch.spikegen.html#snntorch.spikegen.targets_convert">[docs]</a><span class="k">def</span> <span class="nf">targets_convert</span><span class="p">(</span>
    <span class="n">targets</span><span class="p">,</span>
    <span class="n">num_classes</span><span class="p">,</span>
    <span class="n">code</span><span class="o">=</span><span class="s2">&quot;rate&quot;</span><span class="p">,</span>
    <span class="n">num_steps</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">first_spike_time</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">correct_rate</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">incorrect_rate</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">on_target</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">off_target</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">firing_pattern</span><span class="o">=</span><span class="s2">&quot;regular&quot;</span><span class="p">,</span>
    <span class="n">interpolate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">threshold</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
    <span class="n">tau</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">clip</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">bypass</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Spike encoding of targets. Expected input is a 1-D tensor with</span>
<span class="sd">    index of targets.</span>
<span class="sd">    If the output tensor is time-varying, the returned tensor will</span>
<span class="sd">    have time in the first dimension.</span>
<span class="sd">    If it is not time-varying, then the returned tensor will omit</span>
<span class="sd">    the time dimension and use batch first.</span>

<span class="sd">    The following arguments will necessarily incur a time-varying output:</span>
<span class="sd">        ``code=&#39;latency&#39;``, ``first_spike_time!=0``, ``correct_rate!=1``,</span>
<span class="sd">        or ``incorrect_rate!=0``</span>

<span class="sd">    The target output may be applied to the internal state (e.g., membrane)</span>
<span class="sd">    of the neuron or to the spike.</span>
<span class="sd">    The following arguments will produce an output tensor that may</span>
<span class="sd">    sensibly be applied as a target to either the output spike or the</span>
<span class="sd">    membrane potential, as the output will consistently be either a</span>
<span class="sd">    `1` or `0`:</span>
<span class="sd">        ``on_target=1``, ``off_target=0``, and ``interpolate=False``</span>

<span class="sd">    If any of the above 3 conditions do not hold, then the target is</span>
<span class="sd">    better suited for the output membrane potential, as it will likely</span>
<span class="sd">    include values other than `1` and `0`.</span>

<span class="sd">    Example::</span>

<span class="sd">        a = torch.Tensor([4])</span>

<span class="sd">        # rate-coding</span>
<span class="sd">        # one-hot</span>
<span class="sd">        spikegen.targets_convert(a, num_classes=5, code=&quot;rate&quot;)</span>
<span class="sd">        &gt;&gt;&gt; (tensor([[0., 0., 0., 0., 1.]]), )</span>

<span class="sd">        # one-hot + time-first</span>
<span class="sd">        spikegen.targets_convert(a, num_classes=5, code=&quot;rate&quot;,</span>
<span class="sd">        correct_rate=0.8, incorrect_rate=0.2, num_steps=5).size()</span>
<span class="sd">        &gt;&gt;&gt; torch.Size([5, 1, 5])</span>

<span class="sd">    For more examples of rate-coding, see</span>
<span class="sd">    ``help(snntorch.spikegen(targets_rate))``.</span>


<span class="sd">    :param targets: Target tensor for a single batch.</span>
<span class="sd">        The target should be a class index in the range [0, C-1]</span>
<span class="sd">        where C=number of classes.</span>
<span class="sd">    :type targets: torch.Tensor</span>

<span class="sd">    :param num_classes:  Number of outputs.</span>
<span class="sd">    :type num_classes: int</span>

<span class="sd">    :param code:  Encoding scheme. Options of ``&#39;rate&#39;`` or</span>
<span class="sd">        ``&#39;latency&#39;``, defaults to ``&#39;rate&#39;``</span>
<span class="sd">    :type code: string, optional</span>

<span class="sd">    :param num_steps: Number of time steps, defaults to ``False``</span>
<span class="sd">    :type num_steps: int, optional</span>

<span class="sd">    :param first_spike_time: Time step for first spike to occur,</span>
<span class="sd">        defaults to ``0``</span>
<span class="sd">    :type first_spike_time: int, optional</span>

<span class="sd">    :param correct_rate: Firing frequency of correct class as a ratio,</span>
<span class="sd">        e.g., ``1`` enables firing at every step; ``0.5`` enables firing at</span>
<span class="sd">        50% of steps, ``0`` means no firing, defaults to ``1``</span>
<span class="sd">    :type correct_rate: float, optional</span>

<span class="sd">    :param incorrect_rate: Firing frequency of incorrect class(es),</span>
<span class="sd">        e.g., ``1`` enables firing at every step; ``0.5`` enables firing at</span>
<span class="sd">        50% of steps, ``0`` means no firing, defaults to ``0``</span>
<span class="sd">    :type incorrect_rate: float, optional</span>

<span class="sd">    :param on_target: Target at spike times, defaults to ``1``</span>
<span class="sd">    :type on_target: float, optional</span>

<span class="sd">    :param off_target: Target during refractory period, defaults to ``0``</span>
<span class="sd">    :type off_target: float, optional</span>

<span class="sd">    :param firing_pattern: Firing pattern of correct and incorrect classes.</span>
<span class="sd">        ``&#39;regular&#39;`` enables periodic firing, ``&#39;uniform&#39;`` samples spike</span>
<span class="sd">        times from a uniform distributions (duplicates are removed),</span>
<span class="sd">        ``&#39;poisson&#39;`` samples from a binomial distribution at each step where</span>
<span class="sd">        each probability is the firing frequency, defaults to ``&#39;regular&#39;``</span>
<span class="sd">    :type firing_pattern: string, optional</span>

<span class="sd">    :param interpolate: Applies linear interpolation such that there is</span>
<span class="sd">        a gradually increasing target up to each spike, defaults to ``False``</span>
<span class="sd">    :type interpolate: Bool, optional</span>

<span class="sd">    :param epsilon: A tiny positive value to avoid rounding errors when</span>
<span class="sd">        using torch.arange, defaults to ``1e-7``</span>
<span class="sd">    :type epsilon: float, optional</span>

<span class="sd">    :param bypass: Used to block error messages that occur from either: i)</span>
<span class="sd">        spike times exceeding the bounds of ``num_steps``, or ii) if</span>
<span class="sd">        ``num_steps`` is not specified, setting ``bypass=True`` allows</span>
<span class="sd">        the largest spike time to set ``num_steps``. Defaults to ``False``</span>
<span class="sd">    :type bypass: bool, optional</span>

<span class="sd">    :return: spike coded target of output neurons. If targets are</span>
<span class="sd">        time-varying, the output tensor will use time-first dimensions.</span>
<span class="sd">        Otherwise, time is omitted from the tensor.</span>
<span class="sd">    :rtype: torch.Tensor</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># raise exceptions if num_steps is not supplied, and rates have</span>
    <span class="c1"># been specified, or if latency is specified.</span>

    <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="s2">&quot;rate&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">targets_rate</span><span class="p">(</span>
            <span class="n">targets</span><span class="o">=</span><span class="n">targets</span><span class="p">,</span>
            <span class="n">num_classes</span><span class="o">=</span><span class="n">num_classes</span><span class="p">,</span>
            <span class="n">num_steps</span><span class="o">=</span><span class="n">num_steps</span><span class="p">,</span>
            <span class="n">first_spike_time</span><span class="o">=</span><span class="n">first_spike_time</span><span class="p">,</span>
            <span class="n">correct_rate</span><span class="o">=</span><span class="n">correct_rate</span><span class="p">,</span>
            <span class="n">incorrect_rate</span><span class="o">=</span><span class="n">incorrect_rate</span><span class="p">,</span>
            <span class="n">on_target</span><span class="o">=</span><span class="n">on_target</span><span class="p">,</span>
            <span class="n">off_target</span><span class="o">=</span><span class="n">off_target</span><span class="p">,</span>
            <span class="n">firing_pattern</span><span class="o">=</span><span class="n">firing_pattern</span><span class="p">,</span>
            <span class="n">interpolate</span><span class="o">=</span><span class="n">interpolate</span><span class="p">,</span>
            <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># do we need num_steps</span>
    <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="s2">&quot;latency&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">targets_latency</span><span class="p">(</span>
            <span class="n">targets</span><span class="p">,</span>
            <span class="n">num_classes</span><span class="p">,</span>
            <span class="n">num_steps</span><span class="o">=</span><span class="n">num_steps</span><span class="p">,</span>
            <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span>
            <span class="n">tau</span><span class="o">=</span><span class="n">tau</span><span class="p">,</span>
            <span class="n">first_spike_time</span><span class="o">=</span><span class="n">first_spike_time</span><span class="p">,</span>
            <span class="n">clip</span><span class="o">=</span><span class="n">clip</span><span class="p">,</span>
            <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span>
            <span class="n">linear</span><span class="o">=</span><span class="n">linear</span><span class="p">,</span>
            <span class="n">bypass</span><span class="o">=</span><span class="n">bypass</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;code [&#39;</span><span class="si">{</span><span class="n">code</span><span class="si">}</span><span class="s2">&#39;] must be either &#39;rate&#39; or &#39;latency&#39;&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="targets_rate"><a class="viewcode-back" href="../../snntorch.spikegen.html#snntorch.spikegen.targets_rate">[docs]</a><span class="k">def</span> <span class="nf">targets_rate</span><span class="p">(</span>
    <span class="n">targets</span><span class="p">,</span>
    <span class="n">num_classes</span><span class="p">,</span>
    <span class="n">num_steps</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">first_spike_time</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">correct_rate</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">incorrect_rate</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">on_target</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">off_target</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">firing_pattern</span><span class="o">=</span><span class="s2">&quot;regular&quot;</span><span class="p">,</span>
    <span class="n">interpolate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">,</span>
<span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Spike rate encoding of targets. Input tensor must be one-dimensional</span>
<span class="sd">    with target indexes.</span>
<span class="sd">    If the output tensor is time-varying, the returned tensor will have</span>
<span class="sd">    time in the first dimension.</span>
<span class="sd">    If it is not time-varying, then the returned tensor will omit the time</span>
<span class="sd">    dimension and use batch first.</span>
<span class="sd">    If ``first_spike_time!=0``, ``correct_rate!=1``, or ``incorrect_rate!=0``,</span>
<span class="sd">    the output tensor will be time-varying.</span>

<span class="sd">    If ``on_target=1``, ``off_target=0``, and ``interpolate=False``,</span>
<span class="sd">    then the target may sensibly be applied as a target for the output spike.</span>
<span class="sd">    IF any of the above 3 conditions do not hold, then the target would</span>
<span class="sd">    be better suited for the output membrane potential.</span>


<span class="sd">    Example::</span>

<span class="sd">        a = torch.Tensor([4])</span>

<span class="sd">        # one-hot</span>
<span class="sd">        spikegen.targets_rate(a, num_classes=5)</span>
<span class="sd">        &gt;&gt;&gt; (tensor([[0., 0., 0., 0., 1.]]), )</span>

<span class="sd">        # first spike time delay, spike evolution over time</span>
<span class="sd">        spikegen.targets_rate(a, num_classes=5, num_steps=5,</span>
<span class="sd">        first_spike_time=2).size()</span>
<span class="sd">        &gt;&gt;&gt; torch.Size([5, 1, 5])</span>
<span class="sd">        spikegen.targets_rate(a, num_classes=5, num_steps=5,</span>
<span class="sd">        first_spike_time=2)[:, 0, 4]</span>
<span class="sd">        &gt;&gt;&gt; (tensor([0., 0., 1., 1., 1.]))</span>

<span class="sd">        # note: time has not been repeated because every time step</span>
<span class="sd">         would be identical where first_spike_time defaults to 0</span>
<span class="sd">        spikegen.targets_rate(a, num_classes=5, num_steps=5).size()</span>
<span class="sd">        &gt;&gt;&gt; torch.Size([1, 5])</span>

<span class="sd">        # on/off targets - membrane evolution over time</span>
<span class="sd">        spikegen.targets_rate(a, num_classes=5, num_steps=5,</span>
<span class="sd">        first_spike_time=2, on_target=1.2, off_target=0.5)[:, 0, 4]</span>
<span class="sd">        &gt;&gt;&gt; (tensor([0.5000, 0.5000, 1.2000, 1.2000, 1.2000]))</span>

<span class="sd">        # correct rate at 25% + linear interpolation of membrane evolution</span>
<span class="sd">        spikegen.targets_rate(a, num_classes=5, num_steps=5,</span>
<span class="sd">        correct_rate=0.25, on_target=1.2,</span>
<span class="sd">        off_target=0.5, interpolate=True)[:, 0, 4]</span>
<span class="sd">        &gt;&gt;&gt; tensor([1.2000, 0.5000, 0.7333, 0.9667, 1.2000])</span>


<span class="sd">    :param targets: Target tensor for a single batch. The target</span>
<span class="sd">        should be a class index in the range [0, C-1]</span>
<span class="sd">        where C=number of classes.</span>
<span class="sd">    :type targets: torch.Tensor</span>

<span class="sd">    :param num_classes: Number of outputs.</span>
<span class="sd">    :type num_classes: int</span>

<span class="sd">    :param num_steps: Number of time steps, defaults to ``False``</span>
<span class="sd">    :type num_steps: int, optional</span>

<span class="sd">    :param first_spike_time: Time step for first spike to occur,</span>
<span class="sd">        defaults to ``0``</span>
<span class="sd">    :type first_spike_time: int, optional</span>

<span class="sd">    :param correct_rate: Firing frequency of correct class as a</span>
<span class="sd">        ratio, e.g., ``1`` enables firing at every step; ``0.5``</span>
<span class="sd">        enables firing at 50% of steps, ``0`` means no firing,</span>
<span class="sd">        defaults to ``1``</span>
<span class="sd">    :type correct_rate: float, optional</span>

<span class="sd">    :param incorrect_rate: Firing frequency of incorrect class(es), e.g.,</span>
<span class="sd">        ``1`` enables firing at every step; ``0.5``</span>
<span class="sd">        enables firing at 50% of steps,</span>
<span class="sd">        ``0`` means no firing, defaults to ``0``</span>
<span class="sd">    :type incorrect_rate: float, optional</span>

<span class="sd">    :param on_target: Target at spike times, defaults to ``1``</span>
<span class="sd">    :type on_target: float, optional</span>

<span class="sd">    :param off_target: Target during refractory period, defaults to ``0``</span>
<span class="sd">    :type off_target: float, optional</span>

<span class="sd">    :param firing_pattern: Firing pattern of correct and incorrect classes.</span>
<span class="sd">        ``&#39;regular&#39;`` enables periodic firing, ``&#39;uniform&#39;`` samples spike</span>
<span class="sd">        times from a uniform distributions (duplicates are removed),</span>
<span class="sd">        ``&#39;poisson&#39;`` samples from a binomial distribution at each step</span>
<span class="sd">        where each probability is the firing frequency,</span>
<span class="sd">        defaults to ``&#39;regular&#39;``</span>
<span class="sd">    :type firing_pattern: string, optional</span>

<span class="sd">    :param interpolate: Applies linear interpolation such that there</span>
<span class="sd">        is a gradually increasing target</span>
<span class="sd">        up to each spike, defaults to ``False``</span>
<span class="sd">    :type interpolate: Bool, optional</span>

<span class="sd">    :param epsilon:  A tiny positive value to avoid rounding errors when</span>
<span class="sd">        using torch.arange, defaults to ``1e-7``</span>
<span class="sd">    :type epsilon: float, optional</span>

<span class="sd">    :return: rate coded target of output neurons. If targets are</span>
<span class="sd">        time-varying, the output tensor will use time-first dimensions.</span>
<span class="sd">        Otherwise, time is omitted from the tensor.</span>
<span class="sd">    :rtype: torch.Tensor</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">correct_rate</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">incorrect_rate</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;``correct_rate``</span><span class="si">{</span><span class="n">correct_rate</span><span class="si">}</span><span class="s2"> and &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;``incorrect_rate``</span><span class="si">{</span><span class="n">incorrect_rate</span><span class="si">}</span><span class="s2"> must be between 0 and 1.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">num_steps</span> <span class="ow">and</span> <span class="p">(</span><span class="n">correct_rate</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">incorrect_rate</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
            <span class="s2">&quot;``num_steps`` must be passed if correct_rate is not 1 or &quot;</span>
            <span class="s2">&quot;incorrect_rate is not 0.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">incorrect_rate</span> <span class="o">&gt;</span> <span class="n">correct_rate</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
            <span class="s2">&quot;``correct_rate`` must be greater than ``incorrect_rate``.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">firing_pattern</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;regular&quot;</span><span class="p">,</span> <span class="s2">&quot;uniform&quot;</span><span class="p">,</span> <span class="s2">&quot;poisson&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
            <span class="s2">&quot;``firing_pattern`` must be either &#39;regular&#39;, &#39;uniform&#39; or &quot;</span>
            <span class="s2">&quot;&#39;poisson&#39;.&quot;</span>
        <span class="p">)</span>

    <span class="n">device</span> <span class="o">=</span> <span class="n">targets</span><span class="o">.</span><span class="n">device</span>

    <span class="c1"># return a non time-varying tensor</span>
    <span class="k">if</span> <span class="n">correct_rate</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">incorrect_rate</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">first_spike_time</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">on_target</span> <span class="o">&gt;</span> <span class="n">off_target</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span>
                    <span class="n">to_one_hot</span><span class="p">(</span><span class="n">targets</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">)</span> <span class="o">*</span> <span class="n">on_target</span><span class="p">,</span> <span class="n">off_target</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">to_one_hot</span><span class="p">(</span><span class="n">targets</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">)</span> <span class="o">*</span> <span class="n">on_target</span>
                    <span class="o">+</span> <span class="o">~</span><span class="p">(</span><span class="n">to_one_hot</span><span class="p">(</span><span class="n">targets</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">))</span><span class="o">.</span><span class="n">bool</span><span class="p">()</span> <span class="o">*</span> <span class="n">off_target</span>
                <span class="p">)</span>

        <span class="c1"># return time-varying tensor: off up to first_spike_time,</span>
        <span class="c1"># then correct classes are on after</span>
        <span class="k">if</span> <span class="n">first_spike_time</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">spike_targets</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span>
                <span class="n">to_one_hot</span><span class="p">(</span><span class="n">targets</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">)</span> <span class="o">*</span> <span class="n">on_target</span><span class="p">,</span> <span class="n">off_target</span>
            <span class="p">)</span>
            <span class="n">spike_targets</span> <span class="o">=</span> <span class="n">spike_targets</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
                <span class="nb">tuple</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">num_steps</span><span class="p">]</span>
                    <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spike_targets</span><span class="o">.</span><span class="n">size</span><span class="p">()),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">spike_targets</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">first_spike_time</span><span class="p">]</span> <span class="o">=</span> <span class="n">off_target</span>
            <span class="k">return</span> <span class="n">spike_targets</span>

            <span class="c1"># executes if on/off firing rates are not 100% / 0%</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">one_hot_targets</span> <span class="o">=</span> <span class="n">to_one_hot</span><span class="p">(</span><span class="n">targets</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">)</span>
        <span class="n">one_hot_inverse</span> <span class="o">=</span> <span class="n">to_one_hot_inverse</span><span class="p">(</span><span class="n">one_hot_targets</span><span class="p">)</span>

        <span class="c1"># project one-hot-encodings along the time-axis (0th dim)</span>
        <span class="n">one_hot_targets</span> <span class="o">=</span> <span class="n">one_hot_targets</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
            <span class="nb">tuple</span><span class="p">(</span>
                <span class="p">[</span><span class="n">num_steps</span><span class="p">]</span>
                <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">one_hot_targets</span><span class="o">.</span><span class="n">size</span><span class="p">()),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">one_hot_inverse</span> <span class="o">=</span> <span class="n">one_hot_inverse</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
            <span class="nb">tuple</span><span class="p">(</span>
                <span class="p">[</span><span class="n">num_steps</span><span class="p">]</span>
                <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">one_hot_inverse</span><span class="o">.</span><span class="n">size</span><span class="p">()),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># create tensor of spike_targets for correct class</span>
        <span class="n">correct_spike_targets</span><span class="p">,</span> <span class="n">correct_spike_times</span> <span class="o">=</span> <span class="n">target_rate_code</span><span class="p">(</span>
            <span class="n">num_steps</span><span class="o">=</span><span class="n">num_steps</span><span class="p">,</span>
            <span class="n">first_spike_time</span><span class="o">=</span><span class="n">first_spike_time</span><span class="p">,</span>
            <span class="n">rate</span><span class="o">=</span><span class="n">correct_rate</span><span class="p">,</span>
            <span class="n">firing_pattern</span><span class="o">=</span><span class="n">firing_pattern</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">correct_spikes_one_hot</span> <span class="o">=</span> <span class="n">one_hot_targets</span> <span class="o">*</span> <span class="n">correct_spike_targets</span><span class="o">.</span><span class="n">to</span><span class="p">(</span>
            <span class="n">device</span>
        <span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span>
            <span class="o">-</span><span class="mi">1</span>
        <span class="p">)</span>  <span class="c1"># the two unsquezes make the dims of correct_spikes</span>
        <span class="c1"># num_steps x 1 x 1, s.t. time is broadcast in every other direction</span>

        <span class="c1"># create tensor of spike targets for incorrect class</span>
        <span class="n">incorrect_spike_targets</span><span class="p">,</span> <span class="n">incorrect_spike_times</span> <span class="o">=</span> <span class="n">target_rate_code</span><span class="p">(</span>
            <span class="n">num_steps</span><span class="o">=</span><span class="n">num_steps</span><span class="p">,</span>
            <span class="n">first_spike_time</span><span class="o">=</span><span class="n">first_spike_time</span><span class="p">,</span>
            <span class="n">rate</span><span class="o">=</span><span class="n">incorrect_rate</span><span class="p">,</span>
            <span class="n">firing_pattern</span><span class="o">=</span><span class="n">firing_pattern</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">incorrect_spikes_one_hot</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">one_hot_inverse</span> <span class="o">*</span> <span class="n">incorrect_spike_targets</span><span class="p">)</span>
            <span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
            <span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>  <span class="c1"># the two unsquezes make the dims of correct_spikes</span>
        <span class="c1"># num_steps x 1 x 1, s.t. time is broadcasted in every other direction</span>

        <span class="c1"># merge the incorrect and correct tensors</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">interpolate</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">incorrect_spikes_one_hot</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
                    <span class="o">+</span> <span class="n">correct_spikes_one_hot</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="o">*</span> <span class="n">on_target</span><span class="p">,</span>
                <span class="n">off_target</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># interpolate values between spikes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">correct_spike_targets</span> <span class="o">=</span> <span class="n">one_hot_targets</span> <span class="o">*</span> <span class="p">(</span>
                <span class="n">rate_interpolate</span><span class="p">(</span>
                    <span class="n">correct_spike_times</span><span class="p">,</span>
                    <span class="n">num_steps</span><span class="o">=</span><span class="n">num_steps</span><span class="p">,</span>
                    <span class="n">on_target</span><span class="o">=</span><span class="n">on_target</span><span class="p">,</span>
                    <span class="n">off_target</span><span class="o">=</span><span class="n">off_target</span><span class="p">,</span>
                    <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
                <span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>  <span class="c1"># the two unsquezes make the dims of correct_spikes</span>
            <span class="c1"># num_steps x 1 x 1, s.t. the time is broadcasted in every</span>
            <span class="c1"># other direction</span>
            <span class="n">incorrect_spike_targets</span> <span class="o">=</span> <span class="n">one_hot_inverse</span> <span class="o">*</span> <span class="p">(</span>
                <span class="n">rate_interpolate</span><span class="p">(</span>
                    <span class="n">incorrect_spike_times</span><span class="p">,</span>
                    <span class="n">num_steps</span><span class="o">=</span><span class="n">num_steps</span><span class="p">,</span>
                    <span class="n">on_target</span><span class="o">=</span><span class="n">on_target</span><span class="p">,</span>
                    <span class="n">off_target</span><span class="o">=</span><span class="n">off_target</span><span class="p">,</span>
                    <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
                <span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">correct_spike_targets</span> <span class="o">+</span> <span class="n">incorrect_spike_targets</span></div>


<div class="viewcode-block" id="target_rate_code"><a class="viewcode-back" href="../../snntorch.spikegen.html#snntorch.spikegen.target_rate_code">[docs]</a><span class="k">def</span> <span class="nf">target_rate_code</span><span class="p">(</span>
    <span class="n">num_steps</span><span class="p">,</span> <span class="n">first_spike_time</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">rate</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">firing_pattern</span><span class="o">=</span><span class="s2">&quot;regular&quot;</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rate coding a single output neuron of tensor of length ``num_steps``</span>
<span class="sd">    containing spikes, and another tensor containing the spike times.</span>


<span class="sd">    Example::</span>

<span class="sd">        spikegen.target_rate_code(num_steps=5, rate=1)</span>
<span class="sd">        &gt;&gt;&gt; (tensor([1., 1., 1., 1., 1.]), tensor([0, 1, 2, 3, 4]))</span>

<span class="sd">        spikegen.target_rate_code(num_steps=5, first_spike_time=3, rate=1)</span>
<span class="sd">        &gt;&gt;&gt; (tensor([0., 0., 0., 1., 1.]), tensor([3, 4]))</span>

<span class="sd">        spikegen.target_rate_code(num_steps=5, rate=0.3)</span>
<span class="sd">        &gt;&gt;&gt; (tensor([1., 0., 0., 1., 0.]), tensor([0, 3]))</span>

<span class="sd">        spikegen.target_rate_code(</span>
<span class="sd">        num_steps=5, rate=0.3, firing_pattern=&quot;poisson&quot;)</span>
<span class="sd">        &gt;&gt;&gt; (tensor([0., 1., 0., 1., 0.]), tensor([1, 3]))</span>

<span class="sd">    :param num_steps: Number of time steps, defaults to ``False``</span>
<span class="sd">    :type num_steps: int, optional</span>

<span class="sd">    :param first_spike_time: Time step for first spike to occur,</span>
<span class="sd">        defaults to ``0``</span>
<span class="sd">    :type first_spike_time: int, optional</span>

<span class="sd">    :param rate: Firing frequency as a ratio, e.g., ``1``</span>
<span class="sd">        enables firing at every step; ``0.5`` enables firing at 50% of steps,</span>
<span class="sd">        ``0`` means no firing, defaults to ``1``</span>
<span class="sd">    :type rate: float, optional</span>

<span class="sd">    :param firing_pattern: Firing pattern of correct and</span>
<span class="sd">        incorrect classes. ``&#39;regular&#39;`` enables periodic firing,</span>
<span class="sd">        ``&#39;uniform&#39;`` samples spike times from a uniform distributions</span>
<span class="sd">        (duplicates are removed), ``&#39;poisson&#39;`` samples from a binomial</span>
<span class="sd">        distribution at each step where each probability</span>
<span class="sd">        is the firing frequency,</span>
<span class="sd">        defaults to ``&#39;regular&#39;``</span>
<span class="sd">    :type firing_pattern: string, optional</span>

<span class="sd">    :return: rate coded target of single neuron class of length ``num_steps``</span>
<span class="sd">    :rtype: torch.Tensor</span>

<span class="sd">    :return: rate coded spike times in terms of steps</span>
<span class="sd">    :rtype: torch.Tensor</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">rate</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;``rate``</span><span class="si">{</span><span class="n">rate</span><span class="si">}</span><span class="s2"> must be between 0 and 1.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">first_spike_time</span> <span class="o">&gt;</span> <span class="n">num_steps</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;``first_spike_time </span><span class="si">{</span><span class="n">first_spike_time</span><span class="si">}</span><span class="s2"> must be less &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;than num_steps </span><span class="si">{</span><span class="n">num_steps</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">rate</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_steps</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">firing_pattern</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;regular&quot;</span><span class="p">:</span>
        <span class="n">spike_times</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">first_spike_time</span><span class="p">,</span> <span class="n">num_steps</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">rate</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_steps</span><span class="p">)</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">spike_times</span><span class="o">.</span><span class="n">long</span><span class="p">(),</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">spike_times</span><span class="o">.</span><span class="n">long</span><span class="p">(),</span>
        <span class="p">)</span>

    <span class="k">elif</span> <span class="n">firing_pattern</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;uniform&quot;</span><span class="p">:</span>
        <span class="n">spike_times</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">first_spike_time</span><span class="p">,</span> <span class="n">num_steps</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">rate</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="o">*</span> <span class="p">(</span><span class="n">num_steps</span> <span class="o">-</span> <span class="n">first_spike_time</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">first_spike_time</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_steps</span><span class="p">)</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">spike_times</span><span class="o">.</span><span class="n">long</span><span class="p">(),</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">spike_times</span><span class="o">.</span><span class="n">long</span><span class="p">(),</span>
        <span class="p">)</span>

    <span class="k">elif</span> <span class="n">firing_pattern</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;poisson&quot;</span><span class="p">:</span>
        <span class="n">spike_targets</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">bernoulli</span><span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="c1"># torch.zeros((first_spike_time), device=device),</span>
                    <span class="c1"># torch.ones((num_steps - first_spike_time),</span>
                    <span class="c1"># device=device) * rate,</span>
                    <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">first_spike_time</span><span class="p">)),</span>
                    <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">num_steps</span> <span class="o">-</span> <span class="n">first_spike_time</span><span class="p">))</span> <span class="o">*</span> <span class="n">rate</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">spike_targets</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">spike_targets</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="rate_interpolate"><a class="viewcode-back" href="../../snntorch.spikegen.html#snntorch.spikegen.rate_interpolate">[docs]</a><span class="k">def</span> <span class="nf">rate_interpolate</span><span class="p">(</span>
    <span class="n">spike_time</span><span class="p">,</span> <span class="n">num_steps</span><span class="p">,</span> <span class="n">on_target</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">off_target</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-7</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply linear interpolation to a tensor of target spike times to</span>
<span class="sd">    enable gradual increasing membrane.</span>

<span class="sd">    Example::</span>

<span class="sd">        a = torch.Tensor([0, 4])</span>
<span class="sd">        spikegen.rate_interpolate(a, num_steps=5)</span>
<span class="sd">        &gt;&gt;&gt; tensor([1.0000, 0.0000, 0.3333, 0.6667, 1.0000])</span>

<span class="sd">        spikegen.rate_interpolate(a, num_steps=5, on_target=1.25,</span>
<span class="sd">        off_target=0.25)</span>
<span class="sd">        &gt;&gt;&gt; tensor([1.2500, 0.2500, 0.5833, 0.9167, 1.2500])</span>

<span class="sd">    :param spike_time: spike time targets in terms of steps</span>
<span class="sd">    :type targets: torch.Tensor</span>

<span class="sd">    :param num_steps: Number of time steps, defaults to ``False``</span>
<span class="sd">    :type num_steps: int, optional</span>

<span class="sd">    :param on_target: Target at spike times, defaults to ``1``</span>
<span class="sd">    :type on_target: float, optional</span>

<span class="sd">    :param off_target: Target during refractory period, defaults to ``0``</span>
<span class="sd">    :type off_target: float, optional</span>

<span class="sd">    :param epsilon:  A tiny positive value to avoid rounding errors when</span>
<span class="sd">        using torch.arange, defaults to ``1e-7``</span>
<span class="sd">    :type epsilon: float, optional</span>

<span class="sd">    :return: interpolated target of output neurons. Output tensor will</span>
<span class="sd">        use time-first dimensions.</span>
<span class="sd">    :rtype: torch.Tensor</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># if no spikes</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">spike_time</span><span class="o">.</span><span class="n">numel</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">num_steps</span><span class="p">))</span> <span class="o">*</span> <span class="n">off_target</span>

    <span class="n">current_time</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="n">interpolated_targets</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">([])</span>

    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_steps</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">step</span> <span class="ow">in</span> <span class="n">spike_time</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">step</span> <span class="o">==</span> <span class="p">(</span><span class="n">current_time</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">interpolated_targets</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">interpolated_targets</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">([</span><span class="n">on_target</span><span class="p">]))</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">interpolated_targets</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="n">interpolated_targets</span><span class="p">,</span>
                        <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
                            <span class="n">off_target</span><span class="p">,</span>
                            <span class="n">on_target</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">,</span>
                            <span class="p">(</span><span class="n">on_target</span> <span class="o">-</span> <span class="n">off_target</span><span class="p">)</span>
                            <span class="o">/</span> <span class="p">(</span><span class="n">step</span> <span class="o">-</span> <span class="n">current_time</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
                        <span class="p">),</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="n">current_time</span> <span class="o">=</span> <span class="n">step</span>

    <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">spike_time</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_steps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">spike_time</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()),</span> <span class="n">num_steps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">interpolated_targets</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span>
                <span class="p">(</span><span class="n">interpolated_targets</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">([</span><span class="n">off_target</span><span class="p">]))</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="n">interpolated_targets</span></div>


<div class="viewcode-block" id="latency_interpolate"><a class="viewcode-back" href="../../snntorch.spikegen.html#snntorch.spikegen.latency_interpolate">[docs]</a><span class="k">def</span> <span class="nf">latency_interpolate</span><span class="p">(</span><span class="n">spike_time</span><span class="p">,</span> <span class="n">num_steps</span><span class="p">,</span> <span class="n">on_target</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">off_target</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Apply linear interpolation to a tensor of target spike times to</span>
<span class="sd">    enable gradual increasing membrane.</span>
<span class="sd">    Each spike is assumed to occur from a separate neuron.</span>

<span class="sd">    Example::</span>

<span class="sd">        a = torch.Tensor([0, 4])</span>
<span class="sd">        spikegen.latency_interpolate(a, num_steps=5)</span>
<span class="sd">        &gt;&gt;&gt; tensor([[1.0000, 0.0000],</span>
<span class="sd">                    [0.0000, 0.2500],</span>
<span class="sd">                    [0.0000, 0.5000],</span>
<span class="sd">                    [0.0000, 0.7500],</span>
<span class="sd">                    [0.0000, 1.0000]])</span>

<span class="sd">        spikegen.latency_interpolate(a, num_steps=5, on_target=1.25,</span>
<span class="sd">        off_target=0.25)</span>
<span class="sd">        &gt;&gt;&gt; tensor([[1.2500, 0.2500],</span>
<span class="sd">                    [0.2500, 0.5000],</span>
<span class="sd">                    [0.2500, 0.7500],</span>
<span class="sd">                    [0.2500, 1.0000],</span>
<span class="sd">                    [0.2500, 1.2500]])</span>

<span class="sd">    :param spike_time: spike time targets in terms of steps</span>
<span class="sd">    :type targets: torch.Tensor</span>

<span class="sd">    :param num_steps: Number of time steps, defaults to ``False``</span>
<span class="sd">    :type num_steps: int, optional</span>

<span class="sd">    :param on_target: Target at spike times, defaults to ``1``</span>
<span class="sd">    :type on_target: float, optional</span>

<span class="sd">    :param off_target: Target during refractory period, defaults to ``0``</span>
<span class="sd">    :type off_target: float, optional</span>

<span class="sd">    :return: interpolated target of output neurons. Output tensor will use</span>
<span class="sd">        time-first dimensions.</span>
<span class="sd">    :rtype: torch.Tensor</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">on_target</span> <span class="o">&lt;</span> <span class="n">off_target</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;``on_target`` [</span><span class="si">{</span><span class="n">on_target</span><span class="si">}</span><span class="s2">] must be greater than &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;``off_target`` [</span><span class="si">{</span><span class="n">off_target</span><span class="si">}</span><span class="s2">].&quot;</span>
        <span class="p">)</span>

    <span class="n">device</span> <span class="o">=</span> <span class="n">spike_time</span><span class="o">.</span><span class="n">device</span>

    <span class="n">spike_time</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">round</span><span class="p">(</span>
        <span class="n">spike_time</span>
    <span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>  <span class="c1"># Needs to be float as 0s and out-of-bounds spikes</span>
    <span class="c1"># are set to 0.5</span>

    <span class="n">spike_time</span><span class="p">[</span>
        <span class="n">spike_time</span> <span class="o">&gt;</span> <span class="n">num_steps</span>
    <span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>  <span class="c1"># avoid div by 0. instead setting spike time to &lt; 1</span>
    <span class="c1"># --&gt; (step/spike_time) &gt; 1, which gets clipped.</span>

    <span class="n">interpolated_targets</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span>
        <span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">num_steps</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">spike_time</span><span class="o">.</span><span class="n">size</span><span class="p">()))),</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># offset skips first step if a 0 spike occurs. must be handled</span>
    <span class="c1"># separately to avoid div by zero.</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># index into first step</span>
    <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">spike_time</span><span class="p">:</span>
        <span class="n">interpolated_targets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">spike_time</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">interpolated_targets</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">interpolated_targets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>  <span class="c1"># replace 0&#39;s with ones for first spike time, others with 0s</span>
        <span class="n">spike_time</span><span class="p">[</span><span class="n">spike_time</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># i.e., when step/spike_time=1</span>
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_steps</span> <span class="o">-</span> <span class="n">offset</span><span class="p">):</span>
        <span class="n">interpolated_targets</span><span class="p">[</span><span class="n">step</span> <span class="o">+</span> <span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">step</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span> <span class="o">/</span> <span class="n">spike_time</span>

    <span class="c1"># next we clamp those that exceed 1, and rescale</span>
    <span class="n">interpolated_targets</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">interpolated_targets</span> <span class="o">*</span> <span class="p">(</span><span class="n">on_target</span> <span class="o">-</span> <span class="n">off_target</span><span class="p">)</span> <span class="o">+</span> <span class="n">off_target</span>
    <span class="p">)</span>
    <span class="n">interpolated_targets</span><span class="p">[</span><span class="n">interpolated_targets</span> <span class="o">&gt;</span> <span class="n">on_target</span><span class="p">]</span> <span class="o">=</span> <span class="n">off_target</span>

    <span class="k">return</span> <span class="n">interpolated_targets</span></div>


<div class="viewcode-block" id="targets_latency"><a class="viewcode-back" href="../../snntorch.spikegen.html#snntorch.spikegen.targets_latency">[docs]</a><span class="k">def</span> <span class="nf">targets_latency</span><span class="p">(</span>
    <span class="n">targets</span><span class="p">,</span>
    <span class="n">num_classes</span><span class="p">,</span>
    <span class="n">num_steps</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">first_spike_time</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">on_target</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">off_target</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">interpolate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">threshold</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
    <span class="n">tau</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">clip</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">bypass</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Latency encoding of target labels. Use target labels to determine</span>
<span class="sd">    time-to-first spike. Expected input is index of correct class.</span>
<span class="sd">    The index is one-hot-encoded before being passed to ``spikegen.latency``.</span>

<span class="sd">    Assume a LIF neuron model that charges up with time constant tau.</span>
<span class="sd">    Tensor dimensions use time first.</span>

<span class="sd">    Example::</span>

<span class="sd">        a = torch.Tensor([0, 3])</span>
<span class="sd">        spikegen.targets_latency(a, num_classes=4, num_steps=5,</span>
<span class="sd">        normalize=True).size()</span>
<span class="sd">        &gt;&gt;&gt; torch.Size([5, 2, 4])</span>

<span class="sd">        # time evolution of correct neuron class</span>
<span class="sd">        spikegen.targets_latency(a, num_classes=4, num_steps=5,</span>
<span class="sd">        normalize=True)[:, 0, 0]</span>
<span class="sd">        &gt;&gt;&gt; tensor([1., 0., 0., 0., 0.])</span>

<span class="sd">        # time evolution of incorrect neuron class</span>
<span class="sd">        spikegen.targets_latency(a, num_classes=4, num_steps=5,</span>
<span class="sd">        normalize=True)[:, 0, 1]</span>
<span class="sd">        &gt;&gt;&gt; tensor([0., 0., 0., 0., 1.])</span>

<span class="sd">        # correct class w/interpolation</span>
<span class="sd">        spikegen.targets_latency(a, num_classes=4, num_steps=5,</span>
<span class="sd">        normalize=True, interpolate=True)[:, 0, 0]</span>
<span class="sd">        &gt;&gt;&gt; tensor([1., 0., 0., 0., 0.])</span>

<span class="sd">        # incorrect class w/interpolation</span>
<span class="sd">        spikegen.targets_latency(a, num_classes=4, num_steps=5,</span>
<span class="sd">        normalize=True, interpolate=True)[:, 0, 1]</span>
<span class="sd">        &gt;&gt;&gt; tensor([0.0000, 0.2500, 0.5000, 0.7500, 1.0000])</span>

<span class="sd">    :param targets: Target tensor for a single batch. The target</span>
<span class="sd">        should be a class index in the range [0, C-1]</span>
<span class="sd">        where C=number of classes.</span>
<span class="sd">    :type targets: torch.Tensor</span>

<span class="sd">    :param num_classes: Number of outputs.</span>
<span class="sd">    :type num_classes: int</span>

<span class="sd">    :param num_steps: Number of time steps. Explicitly needed if</span>
<span class="sd">        ``normalize=True``, defaults to ``False``</span>
<span class="sd">        (then changed to ``1`` if ``normalize=False``)</span>
<span class="sd">    :type num_steps: int, optional</span>

<span class="sd">    :param first_spike_time: Time to first spike, defaults to ``0``.</span>
<span class="sd">    :type first_spike_time: int, optional</span>

<span class="sd">    :param on_target: Target at spike times, defaults to ``1``</span>
<span class="sd">    :type on_target: float, optional</span>

<span class="sd">    :param off_target: Target during refractory period, defaults to ``0``</span>
<span class="sd">    :type off_target: float, optional</span>

<span class="sd">    :param interpolate: Applies linear interpolation such that there is</span>
<span class="sd">        a gradually increasing target up to each spike, defaults to ``False``</span>
<span class="sd">    :type interpolate: Bool, optional</span>

<span class="sd">    :param threshold: Input features below the threhold will fire at the</span>
<span class="sd">        final time step unless ``clip=True`` in which case they will not fire</span>
<span class="sd">        at all, defaults to ``0.01``</span>
<span class="sd">    :type threshold: float, optional</span>

<span class="sd">    :param tau:  RC Time constant for LIF model used to calculate firing</span>
<span class="sd">        time, defaults to ``1``</span>
<span class="sd">    :type tau: float, optional</span>

<span class="sd">    :param clip: Option to remove spikes from features that fall below</span>
<span class="sd">        the threshold, defaults to ``False``</span>
<span class="sd">    :type clip: Bool, optional</span>

<span class="sd">    :param normalize: Option to normalize the latency code such that the</span>
<span class="sd">        final spike(s) occur within num_steps, defaults to ``False``</span>
<span class="sd">    :type normalize: Bool, optional</span>

<span class="sd">    :param linear: Apply a linear latency code rather than the default</span>
<span class="sd">        logarithmic code, defaults to ``False``</span>
<span class="sd">    :type linear: Bool, optional</span>

<span class="sd">    :param bypass: Used to block error messages that occur from either: i)</span>
<span class="sd">        spike times exceeding the bounds of ``num_steps``, or ii) if</span>
<span class="sd">        ``num_steps`` is not specified, setting ``bypass=True``</span>
<span class="sd">        allows the largest spike time to set ``num_steps``.</span>
<span class="sd">        Defaults to ``False``</span>
<span class="sd">    :type bypass: bool, optional</span>

<span class="sd">    :param epsilon: A tiny positive value to avoid rounding errors when</span>
<span class="sd">        using torch.arange, defaults to ``1e-7``</span>
<span class="sd">    :type epsilon: float, optional</span>

<span class="sd">    :return: latency encoding spike train of features or labels</span>
<span class="sd">    :rtype: torch.Tensor</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">latency</span><span class="p">(</span>
        <span class="n">to_one_hot</span><span class="p">(</span><span class="n">targets</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">),</span>
        <span class="n">num_steps</span><span class="o">=</span><span class="n">num_steps</span><span class="p">,</span>
        <span class="n">first_spike_time</span><span class="o">=</span><span class="n">first_spike_time</span><span class="p">,</span>
        <span class="n">on_target</span><span class="o">=</span><span class="n">on_target</span><span class="p">,</span>
        <span class="n">off_target</span><span class="o">=</span><span class="n">off_target</span><span class="p">,</span>
        <span class="n">interpolate</span><span class="o">=</span><span class="n">interpolate</span><span class="p">,</span>
        <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span>
        <span class="n">tau</span><span class="o">=</span><span class="n">tau</span><span class="p">,</span>
        <span class="n">clip</span><span class="o">=</span><span class="n">clip</span><span class="p">,</span>
        <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span>
        <span class="n">linear</span><span class="o">=</span><span class="n">linear</span><span class="p">,</span>
        <span class="n">bypass</span><span class="o">=</span><span class="n">bypass</span><span class="p">,</span>
        <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="to_one_hot_inverse"><a class="viewcode-back" href="../../snntorch.spikegen.html#snntorch.spikegen.to_one_hot_inverse">[docs]</a><span class="k">def</span> <span class="nf">to_one_hot_inverse</span><span class="p">(</span><span class="n">one_hot_targets</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Boolean inversion of a matrix of 1&#39;s and 0&#39;s.</span>
<span class="sd">    Used to merge the targets of correct and incorrect neuron classes in</span>
<span class="sd">    ``targets_rate``.</span>

<span class="sd">    Example::</span>

<span class="sd">        a = torch.Tensor([0, 0, 0, 0, 1])</span>
<span class="sd">        spikegen.to_one_hot_inverse(a)</span>
<span class="sd">        &gt;&gt;&gt; tensor([[1., 1., 1., 1., 0.]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">one_hot_inverse</span> <span class="o">=</span> <span class="n">one_hot_targets</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
    <span class="n">one_hot_inverse</span><span class="p">[</span><span class="n">one_hot_targets</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">one_hot_inverse</span><span class="p">[</span><span class="n">one_hot_targets</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">return</span> <span class="n">one_hot_inverse</span></div>


<div class="viewcode-block" id="to_one_hot"><a class="viewcode-back" href="../../snntorch.spikegen.html#snntorch.spikegen.to_one_hot">[docs]</a><span class="k">def</span> <span class="nf">to_one_hot</span><span class="p">(</span><span class="n">targets</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;One hot encoding of target labels.</span>

<span class="sd">    Example::</span>

<span class="sd">        targets = torch.tensor([0, 1, 2, 3])</span>
<span class="sd">        spikegen.targets_to_spikes(targets, num_classes=4)</span>
<span class="sd">        &gt;&gt;&gt; tensor([[1., 0., 0., 0.],</span>
<span class="sd">                    [0., 1., 0., 0.],</span>
<span class="sd">                    [0., 0., 1., 0.],</span>
<span class="sd">                    [0., 0., 0., 1.]])</span>

<span class="sd">    :param targets: Target tensor for a single batch</span>
<span class="sd">    :type targets: torch.Tensor</span>

<span class="sd">    :param num_classes: Number of classes</span>
<span class="sd">    :type num_classes: int</span>

<span class="sd">    :return: one-hot encoding of targets of shape [batch x num_classes]</span>
<span class="sd">    :rtype: torch.Tensor</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">targets</span> <span class="o">&gt;</span> <span class="n">num_classes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;target [</span><span class="si">{</span><span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">targets</span><span class="p">)</span><span class="si">}</span><span class="s2">] is out of bounds for &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;``num_classes`` [</span><span class="si">{</span><span class="n">num_classes</span><span class="si">}</span><span class="s2">]&quot;</span>
        <span class="p">)</span>

    <span class="n">device</span> <span class="o">=</span> <span class="n">targets</span><span class="o">.</span><span class="n">device</span>

    <span class="c1"># Initialize zeros. E.g, for MNIST: (batch_size, 10).</span>
    <span class="n">one_hot</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">targets</span><span class="p">),</span> <span class="n">num_classes</span><span class="p">],</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span>
    <span class="p">)</span>

    <span class="c1"># Unsqueeze converts dims of [100] to [100, 1]</span>
    <span class="n">one_hot</span> <span class="o">=</span> <span class="n">one_hot</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">targets</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">one_hot</span></div>


<div class="viewcode-block" id="from_one_hot"><a class="viewcode-back" href="../../snntorch.spikegen.html#snntorch.spikegen.from_one_hot">[docs]</a><span class="k">def</span> <span class="nf">from_one_hot</span><span class="p">(</span><span class="n">one_hot_label</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert one-hot encoding back into an integer</span>

<span class="sd">    Example::</span>

<span class="sd">        one_hot_label = torch.tensor([[1., 0., 0., 0.],</span>
<span class="sd">                                      [0., 1., 0., 0.],</span>
<span class="sd">                                      [0., 0., 1., 0.],</span>
<span class="sd">                                      [0., 0., 0., 1.]])</span>
<span class="sd">        spikegen.from_one_hot(one_hot_label)</span>
<span class="sd">        &gt;&gt;&gt; tensor([0, 1, 2, 3])</span>

<span class="sd">    :param targets: one-hot label vector</span>
<span class="sd">    :type targets: torch.Tensor</span>

<span class="sd">    :return: targets</span>
<span class="sd">    :rtype: torch.Tensor</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># one_hot_label = torch.where(one_hot_label == 1)[0][0]</span>
    <span class="c1"># return int(one_hot_label)</span>

    <span class="n">one_hot_label</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">one_hot_label</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">one_hot_label</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Jason K. Eshraghian.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>